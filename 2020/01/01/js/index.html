<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS | Jimzjy</title>
    <meta name="description" content="

1.localstorage

    window.onstorage = (e) =&gt; {console.log(e)}
    // 或者这样
    window.addEventListener(&#39;storage&#39;, (e) =&gt; console.log(e))

onstorage以及storage事件，针对都是非当前页面对localStorage进行修改时才会触发 ...">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/blog/assets/css/0.styles.38312d4d.css" as="style"><link rel="preload" href="/blog/assets/js/app.f9c3da35.js" as="script"><link rel="preload" href="/blog/assets/js/6.efbb1a0e.js" as="script"><link rel="preload" href="/blog/assets/js/4.2c1edfeb.js" as="script"><link rel="preload" href="/blog/assets/js/19.88627950.js" as="script"><link rel="prefetch" href="/blog/assets/js/1.e55fcec3.js"><link rel="prefetch" href="/blog/assets/js/10.51af10c9.js"><link rel="prefetch" href="/blog/assets/js/11.51ffef52.js"><link rel="prefetch" href="/blog/assets/js/12.0ff238b0.js"><link rel="prefetch" href="/blog/assets/js/13.c97160b1.js"><link rel="prefetch" href="/blog/assets/js/14.6267ce28.js"><link rel="prefetch" href="/blog/assets/js/15.23e671c3.js"><link rel="prefetch" href="/blog/assets/js/16.6c5d306d.js"><link rel="prefetch" href="/blog/assets/js/17.6c77ee6e.js"><link rel="prefetch" href="/blog/assets/js/18.47ba0375.js"><link rel="prefetch" href="/blog/assets/js/20.c6fdbffa.js"><link rel="prefetch" href="/blog/assets/js/21.1f9420df.js"><link rel="prefetch" href="/blog/assets/js/22.3de1a13b.js"><link rel="prefetch" href="/blog/assets/js/23.9f4a42cb.js"><link rel="prefetch" href="/blog/assets/js/24.cbd28a1a.js"><link rel="prefetch" href="/blog/assets/js/25.4df0175b.js"><link rel="prefetch" href="/blog/assets/js/26.39f08bae.js"><link rel="prefetch" href="/blog/assets/js/27.0b0ee3ef.js"><link rel="prefetch" href="/blog/assets/js/28.ad0eaf6b.js"><link rel="prefetch" href="/blog/assets/js/5.b8c6894d.js"><link rel="prefetch" href="/blog/assets/js/7.dd213c60.js"><link rel="prefetch" href="/blog/assets/js/8.5c3b217f.js"><link rel="prefetch" href="/blog/assets/js/9.e865db1b.js"><link rel="prefetch" href="/blog/assets/js/vuejs-paginate.8d2cad8c.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.38312d4d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/blog/" class="nav-link home-link">Jimzjy </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/blog/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/blog/tag/memo/" class="nav-link">Memo</a></li><li class="nav-item"><a href="https://github.com/Jimzjy/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">GitHub</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/blog/" class="nav-link mobile-home-link">Jimzjy </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/blog/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/blog/tag/memo/" class="nav-link">Memo</a></li><li class="mobile-nav-item"><a href="https://github.com/Jimzjy/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">GitHub</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        JS
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">All</span> <!----></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2020-01-01T00:00:00.000Z">
      Wed Jan 01 2020
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-d832e844><a href="/blog/tag/memo" data-v-d832e844> memo </a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h3 id="多个标签页之间通信的几种方法"><a href="#多个标签页之间通信的几种方法" class="header-anchor">#</a> 多个标签页之间通信的几种方法</h3> <p><strong>1.localstorage</strong></p> <div class="language- extra-class"><pre><code>window.onstorage = (e) =&gt; {console.log(e)}
// 或者这样
window.addEventListener('storage', (e) =&gt; console.log(e))
</code></pre></div><p>onstorage以及storage事件，针对都是<strong>非当前页面</strong>对localStorage进行修改时才会触发，当前页面修改localStorage不会触发监听函数。然后就是在对原有的数据的值进行修改时才会触发，比如原本已经有一个key会a值为b的localStorage，你再执行：<code>localStorage.setItem('a', 'b')</code>代码，同样是不会触发监听函数的.</p> <p><strong>2.webworker</strong></p> <p>普通的webworker直接使用new Worker()即可创建，这种webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的.</p> <p><strong>SharedWorker</strong></p> <p>SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)</p> <p>新建一个js文件worker.js</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// sharedWorker所要用到的js文件，不必打包到项目中，直接放到服务器即可</span>
<span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token string">''</span>
<span class="token function-variable function">onconnect</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> port <span class="token operator">=</span> e<span class="token punctuation">.</span>ports<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

  port<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>data <span class="token operator">===</span> <span class="token string">'get'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      data <span class="token operator">=</span> e<span class="token punctuation">.</span>data
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>webworker端(暂且这样称呼)的代码就如上，只需注册一个onmessage监听信息的事件，客户端(即使用sharedWorker的标签页)发送message时就会触发.</p> <p>注意webworker无法在本地使用, worker.js和index.html在同一目录.</p> <p>index.html</p> <div class="language- extra-class"><pre><code>// 这段代码是必须的，打开页面后注册SharedWorker，显示指定worker.port.start()方法建立与worker间的连接
    if (typeof Worker === &quot;undefined&quot;) {
      alert('当前浏览器不支持webworker')
    } else {
      let worker = new SharedWorker('worker.js')
      worker.port.addEventListener('message', (e) =&gt; {
        console.log('来自worker的数据：', e.data)
      }, false)
      worker.port.start()
      window.worker = worker
    }
// 获取和发送消息都是调用postMessage方法，我这里约定的是传递'get'表示获取数据。
window.worker.port.postMessage('get')
window.worker.port.postMessage('发送信息给worker')
</code></pre></div><h3 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h3> <img src="/blog/js/proto.png"> <ul><li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li> <li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li> <li><code>Function.prototype</code> 和 <code>Object.prototype</code> 是两个特殊的对象，他们由引擎来创建</li> <li>除了以上两个特殊对象，其他对象都是通过构造器 <code>new</code> 出来的</li> <li>函数的 <code>prototype</code> 是一个对象，也就是原型</li> <li>对象的 <code>__proto__</code> 指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li></ul> <p>先有的 Function.prototype 再有的 function Function , 不像 Foo , 是先有的 function Foo 再有的 Foo.prototype, 所以 Function.<strong>proto</strong> === Function.prototype, 这是引擎作出的操作.</p> <p>bind() 生成的没有 prototype (所以不会影响原来的 function), new 它们的时候, 会调用原构造函数, 将原构造函数的 prototype 赋给 对象的 <strong>proto</strong> .</p> <h3 id="prototype作用"><a href="#prototype作用" class="header-anchor">#</a> prototype作用</h3> <ul><li>让实例对象知道是什么函数构造了它</li> <li>如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 <code>xx.constructor.method</code> 来扩展</li></ul> <h3 id="new的过程"><a href="#new的过程" class="header-anchor">#</a> new的过程</h3> <ul><li><p>step1：首先创建一个空对象，这个对象将会作为执行 new 构造函数() 之后，返回的对象实例</p></li> <li><p>step2：将上面创建的空对象的原型（<code>__proto__</code>），指向构造函数的 prototype 属性</p></li> <li><p>step3：将这个空对象赋值给构造函数内部的 this，并执行构造函数逻辑</p></li> <li><p>step4：根据构造函数执行逻辑，返回第一步创建的对象或者构造函数的显式返回值</p> <p>function newFunc(...args) {
// 取出 args 数组第一个参数，即目标构造函数
const constructor = args.shift()</p> <p>// 创建一个空对象，且这个空对象继承构造函数的 prototype 属性
// 即实现 obj.<strong>proto</strong> === constructor.prototype
const obj = Object.create(constructor.prototype)</p> <p>// 执行构造函数，得到构造函数返回结果
// 注意这里我们使用 apply，将构造函数内的 this 指向为 obj
const result = constructor.apply(obj, args)</p> <p>// 如果造函数执行后，返回结果是对象类型，就直接返回，否则返回 obj 对象
return (typeof result === 'object' &amp;&amp; result != null) ? result : obj
}</p></li></ul> <h3 id="this"><a href="#this" class="header-anchor">#</a> this</h3> <p><strong>this 的指向，是在调用函数时根据执行上下文所动态确定的</strong></p> <ul><li>在函数体中，简单调用该函数时（非显式/隐式绑定下），严格模式下 <code>this</code> 绑定到 <code>undefined</code>，否则绑定到全局对象 <code>window</code>／<code>global</code>；</li> <li>一般构造函数 <code>new</code> 调用，绑定到新创建的对象上；</li> <li>一般由 <code>call</code>/<code>apply</code>/<code>bind</code> 方法显式调用，绑定到指定参数的对象上；</li> <li>一般由上下文对象调用，绑定在该对象上；</li> <li>箭头函数中，根据外层上下文绑定的 <code>this</code> 决定 <code>this</code> 指向。</li></ul> <p>非严格模式下的 bind call apply 会把 undefined, null 这些context转成全局对象(window, global)
<img src="/blog/js/bind.jpg"></p> <h3 id="javascript-执行"><a href="#javascript-执行" class="header-anchor">#</a> JavaScript 执行</h3> <ul><li>代码预编译阶段</li> <li>代码执行阶段</li></ul> <p>预编译阶段是前置阶段，这个时候由编译器将 JavaScript 代码编译成可执行的代码。 注意，这里的预编译和传统的编译并不一样，传统的编译非常复杂，涉及分词、解析、代码生成等过程 。这里的预编译是 JavaScript 中独特的概念，虽然 JavaScript 是解释型语言，编译一行，执行一行。但是在代码执行前，JavaScript 引擎确实会做一些「预先准备工作」</p> <p><strong>执行阶段主要任务是执行代码，执行上下文在这个阶段全部创建完成</strong></p> <p>JavaScript 代码在预编译阶段对变量的内存空间进行分配，我们熟悉的变量提升过程便是在此阶段完成的</p> <ul><li><p>预编译阶段进行变量声明；</p></li> <li><p>预编译阶段变量声明进行提升，但是值为 undefined；</p></li> <li><p>预编译阶段所有非表达式的函数声明进行提升。</p> <p>function bar() {
console.log('bar1')
}</p> <p>var bar = function () {
console.log('bar2')
}</p> <p>bar()</p> <p>// 输出：bar2，我们调换顺序：</p> <p>var bar = function () {
console.log('bar2')
}</p> <p>function bar() {
console.log('bar1')
}</p> <p>bar()
// 仍然输出：bar2</p> <p>foo(10)
function foo (num) {
console.log(foo)
foo = num;<br>
console.log(foo)
var foo
}
console.log(foo)
foo = 1
console.log(foo)</p> <p>输出：</p> <p>undefined
10
ƒ foo (num) {
console.log(foo)
foo = num<br>
console.log(foo)
var foo
}
1</p></li></ul> <p>作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完全生成的。因为函数在调用时，才会开始创建对应的执行上下文。</p> <p><strong>执行上下文</strong>包括了：变量对象、作用域链以及 this 的指向</p> <p>变量提升是发生在预编译阶段，也就是执行上下文的创建阶段，这个阶段就是：创建变量对象，创建作用域链，确定this指向，let和const的变量是在执行阶段开始执行的，所以没有在预编译阶段执行，就是没有提升.<br>
JavaScript引擎在扫描代码时，也就是预编译阶段，对于发现的变量声明，要么将它们提升到作用域顶部，也就是var声明的，要么将声明放在暂时性死区，也就是let和const，在执行阶段时，执行到声明语句后，才会从暂时性死区移除.</p> <h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <p>闭包也是一个函数，它也是定义在全局里的，只是它的定义时间是依赖它的包含函数的，之所以闭包能访问外部函数的变量，是因为外部函数内的代码执行，执行到它，它被定义时，它把外部函数的变量对象保存在了自己的<code>[[scope]]</code>属性上.<br>
这个内部函数被返回，然后执行时，第一创建自己的执行环境，然后把<code>[[scope]]</code>里保存的作用域复制过来，把自己的变量对象放在最前端，建立自己的作用域链，所以它依然可以访问外部函数的变量，所以无论闭包还是词法环境，搜索变量的过程都是在作用域链上搜索.<br>
至于它能搜索到哪些变量，取决于它所在的执行环境，也就是this.</p> <h3 id="内存管理基本概念"><a href="#内存管理基本概念" class="header-anchor">#</a> 内存管理基本概念</h3> <ul><li>栈空间：由操作系统自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。</li> <li>堆空间：一般由开发者分配释放，这部分空间就要考虑垃圾回收的问题。</li></ul> <p>一般情况下，基本数据类型保存在栈内存当中，引用类型保存在堆内存当中</p> <h3 id="bind"><a href="#bind" class="header-anchor">#</a> bind</h3> <div class="language- extra-class"><pre><code>Function.prototype.bind = Function.prototype.bind || function (context) {
   var me = this;
   var args = Array.prototype.slice.call(arguments, 1);
   var F = function () {}; // 为了不影响原来的 prototype
   F.prototype = this.prototype;
   var bound = function () {
       var innerArgs = Array.prototype.slice.call(arguments);
       var finalArgs = args.concat(innerArgs);
       return me.apply(this instanceof F ? this : context || this, finalArgs);
   }
   bound.prototype = new F();
   return bound;
}
</code></pre></div><h3 id="apply"><a href="#apply" class="header-anchor">#</a> apply</h3> <div class="language- extra-class"><pre><code>Function.prototype.applyFn = function (targetObject, argsArray) {
   if(typeof argsArray === 'undefined' || argsArray === null) {
       argsArray = []
   }

   if(typeof targetObject === 'undefined' || targetObject === null){
       targetObject = window
   }

   targetObject = new Object(targetObject)

   const targetFnKey = 'targetFnKey'
   targetObject[targetFnKey] = this

   const result = targetObject[targetFnKey](...argsArray)
   delete targetObject[targetFnKey]
   return result
}
</code></pre></div><h3 id="reduce"><a href="#reduce" class="header-anchor">#</a> reduce</h3> <div class="language- extra-class"><pre><code>Array.prototype.reduce = Array.prototype.reduce || function(func, initialValue) {
   var arr = this
   var base = typeof initialValue === 'undefined' ? arr[0] : initialValue
   var startPoint = typeof initialValue === 'undefined' ? 1 : 0
   arr.slice(startPoint)
       .forEach(function(val, index) {
           base = func(base, val, index + startPoint, arr)
       })
   return base
}
</code></pre></div><h3 id="javascript-类型"><a href="#javascript-类型" class="header-anchor">#</a> JavaScript 类型</h3> <ul><li>null</li> <li>undefined</li> <li>boolean</li> <li>number</li> <li>string</li> <li>object</li> <li>symbol</li> <li>bigint</li></ul> <p>object 类型又具体包含了 function、array、date 等。</p> <p><strong>使用 typeof 判断类型</strong></p> <p>使用 typeof 可以准确判断出除 null 以外的基本类型，以及 function 类型、symbol 类型；null 会被 typeof 判断为 object, bigint 为 bigint。</p> <div class="language- extra-class"><pre><code>const foo = () =&gt; 1
typeof foo // &quot;function&quot;
</code></pre></div><p><strong>使用 instanceof 判断类型</strong></p> <p>使用 a instanceof B 判断的是：a 是否为 B 的实例，即 a 的原型链上是否存在 B 构造函数</p> <p><strong>使用 constructor 和 Object.prototype.toString 判断类型</strong></p> <div class="language- extra-class"><pre><code>console.log(Object.prototype.toString.call(1))
// [object Number]
</code></pre></div><h3 id="转换"><a href="#转换" class="header-anchor">#</a> <strong>转换</strong></h3> <p>当使用 + 运算符计算 string 和其他类型相加时，都会转换为 string 类型；其他情况，都会转换为 number 类型，但是 undefined 会转换为 NaN，相加结果也是 NaN</p> <p><strong>复杂类型</strong></p> <p>当使用 + 运算符计算时，如果存在复杂类型，那么复杂类型将会转换为基本类型，再进行运算.</p> <p>对象在转换基本类型时，会调用该对象上 valueOf 或 toString 这两个方法，该方法的返回值是转换为基本类型的结果.</p> <p>那具体调用 valueOf 还是 toString 呢？这是 ES 规范所决定的，实际上这取决于内置的 toPrimitive 调用结果.</p> <div class="language- extra-class"><pre><code>const object1 = {
  [Symbol.toPrimitive](hint) {
    if (hint == 'number') {
			// The hint argument can be one of &quot;number&quot;, &quot;string&quot;, and &quot;default&quot;.
      return 42;
    }
    return null;
  }
};

console.log(+object1);
// expected output: 42
</code></pre></div><h3 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h3> <div class="language- extra-class"><pre><code>function Promise(executor) {
 this.status = 'pending'
 this.value = null
 this.reason = null
 this.onFulfilledArray = []
 this.onRejectedArray = []

 const resolve = value =&gt; {
   if (value instanceof Promise) {
     return value.then(resolve, reject)
   }
   setTimeout(() =&gt; {
     if (this.status === 'pending') {
       this.value = value
       this.status = 'fulfilled'

       this.onFulfilledArray.forEach(func =&gt; {
         func(value)
       })
     }
   })
 }

 const reject = reason =&gt; {
   setTimeout(() =&gt; {
     if (this.status === 'pending') {
       this.reason = reason
       this.status = 'rejected'

       this.onRejectedArray.forEach(func =&gt; {
         func(reason)
       })
     }
   })
 }


   try {
       executor(resolve, reject)
   } catch(e) {
       reject(e)
   }
}

const resolvePromise = (promise2, result, resolve, reject) =&gt; {
 // 当 result 和 promise2 相等时，也就是说 onfulfilled 返回 promise2 时，进行 reject
 if (result === promise2) {
   return reject(new TypeError('error due to circular reference'))
 }

 // 是否已经执行过 onfulfilled 或者 onrejected
 let consumed = false
 let thenable

 if (result instanceof Promise) {
   if (result.status === 'pending') {
     result.then(function(data) {
       resolvePromise(promise2, data, resolve, reject)
     }, reject)
   } else {
     result.then(resolve, reject)
   }
   return
 }

 let isComplexResult = target =&gt; (typeof target === 'function' || typeof target === 'object') &amp;&amp; (target !== null)
 // 如果返回的是疑似 Promise 类型
 if (isComplexResult(result)) {
   try {
     thenable = result.then
     // 如果返回的是 Promise 类型，具有 then 方法
     if (typeof thenable === 'function') {
       thenable.call(result, function(data) {
         if (consumed) {
           return
         }
         consumed = true

         return resolvePromise(promise2, data, resolve, reject)
       }, function(error) {
         if (consumed) {
           return
         }
         consumed = true

         return reject(error)
       })
     }
     else {
       return resolve(result)
     }

   } catch(e) {
     if (consumed) {
       return
     }
     consumed = true
     return reject(e)
   }
 }
 else {
   return resolve(result)
 }
}

Promise.prototype.then = function(onfulfilled, onrejected) {
 onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data =&gt; data
 onrejected = typeof onrejected === 'function' ? onrejected : error =&gt; {throw error}

 // promise2 将作为 then 方法的返回值
 let promise2

 if (this.status === 'fulfilled') {
   return promise2 = new Promise((resolve, reject) =&gt; {
     setTimeout(() =&gt; {
       try {
         // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果
         let result = onfulfilled(this.value)
         resolvePromise(promise2, result, resolve, reject)
       }
       catch(e) {
         reject(e)
       }
     })
   })
 }
 if (this.status === 'rejected') {
   return promise2 = new Promise((resolve, reject) =&gt; {
     setTimeout(() =&gt; {
       try {
         // 这个新的 promise2 reject 的值为 onrejected 的执行结果
        let result = onrejected(this.reason)
        resolvePromise(promise2, result, resolve, reject)
       }
       catch(e) {
         reject(e)
       }
     })
   })
 }
 if (this.status === 'pending') {
   return promise2 = new Promise((resolve, reject) =&gt; {
     this.onFulfilledArray.push(value =&gt; {
       try {
         let result = onfulfilled(value)
         resolvePromise(promise2, result, resolve, reject)
       }
       catch(e) {
         return reject(e)
       }
     })

     this.onRejectedArray.push(reason =&gt; {
       try {
         let result = onrejected(reason)
         resolvePromise(promise2, result, resolve, reject)
       }
       catch(e) {
         return reject(e)
       }
     })      
   })
 }
}

Promise.prototype.catch = function(catchFunc) {
 return this.then(null, catchFunc)
}

Promise.resolve = function(value) {
 return new Promise((resolve, reject) =&gt; {
   resolve(value)
 })
}

Promise.reject = function(value) {
 return new Promise((resolve, reject) =&gt; {
   reject(value)
 })
}

Promise.race = function(promiseArray) {
 if (!Array.isArray(promiseArray)) {
     throw new TypeError('The arguments should be an array!')
 }
 return new Promise((resolve, reject) =&gt; {
   try {
     const length = promiseArray.length
     for (let i = 0; i        promiseArray[i].then(resolve, reject)
     }
   }
   catch(e) {
     reject(e)
   }
 })
}

Promise.all = function (promiseArray) {
  if (!Array.isArray(promiseArray)) {
    throw new TypeError('The arguments should be an array!')
  }
  return new Promise((resolve, reject) =&gt; {
    try {
      let resultArray = []
      let count = 0
      const length = promiseArray.length

      for (let i = 0; i &lt; promiseArray.length; i++) {
        promiseArray[i].then(data =&gt; {
          resultArray[i] = data
          count++

          if (count === length) {
            resolve(resultArray)
          }
        }, reject)
      }
    }
    catch (e) {
      reject(e)
    }
  })
}
</code></pre></div><h3 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h3> <div class="language- extra-class"><pre><code>function inherit(Child, Parent) {
    // 继承原型上的属性
   Child.prototype = Object.create(Parent.prototype)

    // 修复 constructor
   Child.prototype.constructor = Child

   // 存储超类
   Child.super = Parent

   // 静态属性继承
   if (Object.setPrototypeOf) {
       // setPrototypeOf es6
       Object.setPrototypeOf(Child, Parent)
   } else if (Child.__proto__) {
       // __proto__ es6 引入，但是部分浏览器早已支持
       Child.__proto__ = Parent
   } else {
       // 兼容 IE10 等陈旧浏览器
       // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法
       for (var k in Parent) {
           if (Parent.hasOwnProperty(k) &amp;&amp; !(k in Child)) {
               Child[k] = Parent[k]
           }
       }
   }

}
</code></pre></div><p>JavaScript 的日期对象只能通过 JavaScript Date 作为构造函数来实例化得到。</p> <p><strong>Date继承</strong></p> <div class="language- extra-class"><pre><code>function DateConstructor() {
   var dateObj = new(Function.prototype.bind.apply(Date, [Date].concat(Array.prototype.slice.call(arguments))))()

   Object.setPrototypeOf(dateObj, DateConstructor.prototype)

   dateObj.foo = 'bar'

   return dateObj
}

Object.setPrototypeOf(DateConstructor.prototype, Date.prototype)

DateConstructor.prototype.getMyTime = function getTime() {
   return this.getTime()
}

let date = new DateConstructor()

console.log(date.getMyTime())
</code></pre></div><p>整个实现过程通过更改原型关系，在构造函数里调用原生构造函数 Date，并返回其实例的方法，「欺骗了」浏览器。当然这样的做法比较取巧，其副作用是更改了原型关系，这样也会干扰浏览器某些优化操作。</p> <p><strong>ES6</strong></p> <div class="language- extra-class"><pre><code>class DateConstructor extends Date {
   constructor() {
       super()
       this.foo ='bar'
   }
   getMyTime() {
       return this.getTime()
   }
}

let date = new DateConstructor()

// 上面的方法可以完美执行：

date.getMyTime()
// 1558921640586
</code></pre></div><h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> async await</h3> <div class="language- extra-class"><pre><code>async function findPosts() {
  var response = await $.get('/posts');
  try{
     return JSON.parse(response.posts)
  } catch(e) {
     throw new Error(&quot;failed&quot;)
  }
}
</code></pre></div><p>to</p> <div class="language- extra-class"><pre><code>function findPosts() {
    var ctx = this, args = arguments;
    return Promise.resolve().then(function () {
        var response;
        return $.get('/posts').then(function (value) {
            response = value;
            return Promise.resolve().then(function () {
                return JSON.parse(response.posts);
            }).catch(function (e) {
                throw new Error('failed');
            }).then(function () {
            });
        });
    });
}
</code></pre></div><h3 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h3> <p>没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p> <h3 id="类数组转数组"><a href="#类数组转数组" class="header-anchor">#</a> 类数组转数组</h3> <p>Array.prototype.slice.call()</p> <div class="language- extra-class"><pre><code>var toArray = function(s){
	try{  
	   return Array.prototype.slice.call(s);  
	} catch(e){  
	  var arr = [];  
	  for(var i = 0,len = s.length; i &lt; len; i++){   
	       arr[i] = s[i];
		}
	}  
  return arr;  
}
</code></pre></div><p>Array.from()</p> <div class="language- extra-class"><pre><code>var args = Array.from(arguments);
</code></pre></div><p>扩展运算符（…）</p> <div class="language- extra-class"><pre><code>var args = [...arguments];
</code></pre></div><h3 id="纯函数"><a href="#纯函数" class="header-anchor">#</a> 纯函数</h3> <ul><li>相同输入总是会返回相同的输出。</li> <li>不产生副作用。</li> <li>不依赖于外部状态。</li></ul> <p>调用一个纯函数，但是不使用其返回值，无意义.</p> <h3 id="副作用"><a href="#副作用" class="header-anchor">#</a> <strong>副作用</strong></h3> <p>修改全局变量（函数外的变量），修改参数或改变外部存储</p> <h3 id="柯里化"><a href="#柯里化" class="header-anchor">#</a> 柯里化</h3> <div class="language- extra-class"><pre><code>function curry(fn, ...args) {
  return fn.length &lt;= args.length ? fn(...args) : function(...args1) {
    return curry(fn, ...args, ...args1)
  }
}

function plus(a, b, c) {
  return a + b + c
}

console.log(curry(plus)(1)(2)(3))
</code></pre></div><h3 id="偏函数"><a href="#偏函数" class="header-anchor">#</a> 偏函数</h3> <div class="language- extra-class"><pre><code>function partial (fn, ...args) {
	return fn.bind(null, ...args)
}
</code></pre></div><h3 id="proxy"><a href="#proxy" class="header-anchor">#</a> Proxy</h3> <p>支持13种拦截操作</p> <ul><li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy['foo']</code>。</li> <li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy['foo'] = v</code>，返回一个布尔值。</li> <li><strong>has(target, propKey)</strong>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li> <li><strong>deleteProperty(target, propKey)</strong>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li> <li><strong>ownKeys(target)</strong>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li> <li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li> <li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li> <li><strong>preventExtensions(target)</strong>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li> <li><strong>getPrototypeOf(target)</strong>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li> <li><strong>isExtensible(target)</strong>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li> <li><strong>setPrototypeOf(target, proto)</strong>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li> <li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li> <li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li></ul> <h3 id="globalthis"><a href="#globalthis" class="header-anchor">#</a> globalThis</h3> <p>在 Web 中，可以通过 window、self 或者 frames 取到全局对象，但是在 Web Workers 中只有 self 可以。在 Node.js 中，它们都无法获取，必须使用 global。在松散模式下，可以在函数中返回 this 来获取全局对象，但是在严格模式下 this 会返回 undefined 。</p> <h3 id="单例"><a href="#单例" class="header-anchor">#</a> 单例</h3> <div class="language- extra-class"><pre><code>let obj = {}
// 也是单例, 因为在JavaScript创建对象的方式十分灵活, 
// 可以直接通过对象字面量的方式实例化一个对象, 
// 而其他面向对象的语言必须使用类进行实例化

class SingletonApple {
  constructor(name, creator, products) {
    //首次使用构造器实例
    if (!SingletonApple.instance) {
      this.name = name;
      this.creator = creator;
      this.products = products;
      //将this挂载到SingletonApple这个类的instance属性上
      SingletonApple.instance = this;
    }
    return SingletonApple.instance;
  }
}
</code></pre></div><h3 id="装饰器"><a href="#装饰器" class="header-anchor">#</a> 装饰器</h3> <p>Object.assign</p> <div class="language- extra-class"><pre><code>class Math {
  @log
  add(a, b) {
    return a + b;
  }
}

function log(target, name, descriptor) {
  var oldValue = descriptor.value;

  descriptor.value = function() {
    console.log(`Calling ${name} with`, arguments);
    return oldValue.apply(this, arguments);
  };

  return descriptor;
}

const math = new Math();

// passed parameters should get logged now
math.add(2, 4);
</code></pre></div><h3 id="_0-1-0-2-≠-0-3"><a href="#_0-1-0-2-≠-0-3" class="header-anchor">#</a> 0.1+0.2 ≠ 0.3</h3> <p>64位比特又可分为三个部分：</p> <ul><li>符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数</li> <li>指数位E：中间的 11 位存储指数（exponent），用来表示次方数</li> <li>尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零</li></ul> <p><a href="https://user-gold-cdn.xitu.io/2018/3/8/16205c88ea806bac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" target="_blank" rel="noopener noreferrer">https://user-gold-cdn.xitu.io/2018/3/8/16205c88ea806bac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>十进制的0.1和0.2会被转换成二进制的，但是由于浮点数用二进制表示时是无穷的：</p> <div class="language- extra-class"><pre><code>0.1 -&gt; 0.0001 1001 1001 1001...(1100循环)
0.2 -&gt; 0.0011 0011 0011 0011...(0011循环)
</code></pre></div><p>IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持53位二进制位，所以两者相加之后得到二进制为：</p> <div class="language- extra-class"><pre><code>0.0100110011001100110011001100110011001100110011001100
</code></pre></div><p>因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了0.30000000000000004。所以在进行算术计算时会产生误差。</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h3 active"><a href="#多个标签页之间通信的几种方法" title="多个标签页之间通信的几种方法">多个标签页之间通信的几种方法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#原型" title="原型">原型</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#prototype作用" title="prototype作用">prototype作用</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#new的过程" title="new的过程">new的过程</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#this" title="this">this</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#javascript-执行" title="JavaScript 执行">JavaScript 执行</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#闭包" title="闭包">闭包</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#内存管理基本概念" title="内存管理基本概念">内存管理基本概念</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#bind" title="bind">bind</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#apply" title="apply">apply</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#reduce" title="reduce">reduce</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#javascript-类型" title="JavaScript 类型">JavaScript 类型</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#转换" title="转换">转换</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#promise" title="Promise">Promise</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#继承" title="继承">继承</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#async-await" title="async await">async await</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#箭头函数" title="箭头函数">箭头函数</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#类数组转数组" title="类数组转数组">类数组转数组</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#纯函数" title="纯函数">纯函数</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#副作用" title="副作用">副作用</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#柯里化" title="柯里化">柯里化</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#偏函数" title="偏函数">偏函数</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#proxy" title="Proxy">Proxy</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#globalthis" title="globalThis">globalThis</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#单例" title="单例">单例</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#装饰器" title="装饰器">装饰器</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_0-1-0-2-≠-0-3" title="0.1+0.2 ≠ 0.3">0.1+0.2 ≠ 0.3</a></div></div></div></div> <footer class="footer" data-v-582f9766><div class="footer-left-wrap" data-v-582f9766><ul class="contact" data-v-582f9766><li class="contact-item" data-v-582f9766><a href="https://github.com/Jimzjy" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-582f9766><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-582f9766><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-582f9766></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-582f9766><ul class="copyright" data-v-582f9766><li class="copyright-item" data-v-582f9766><a href="/blog/2020/01/01/js/.html" class="nav-link" data-v-582f9766>Touching fish in progress...</a></li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.f9c3da35.js" defer></script><script src="/blog/assets/js/6.efbb1a0e.js" defer></script><script src="/blog/assets/js/4.2c1edfeb.js" defer></script><script src="/blog/assets/js/19.88627950.js" defer></script>
  </body>
</html>
