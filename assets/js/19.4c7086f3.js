(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{357:function(t,n,e){"use strict";e.r(n);var r=e(9),s=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"多个标签页之间通信的几种方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多个标签页之间通信的几种方法"}},[t._v("#")]),t._v(" 多个标签页之间通信的几种方法")]),t._v(" "),e("p",[e("strong",[t._v("1.localstorage")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("window.onstorage = (e) => {console.log(e)}\n// 或者这样\nwindow.addEventListener('storage', (e) => console.log(e))\n")])])]),e("p",[t._v("onstorage以及storage事件，针对都是"),e("strong",[t._v("非当前页面")]),t._v("对localStorage进行修改时才会触发，当前页面修改localStorage不会触发监听函数。然后就是在对原有的数据的值进行修改时才会触发，比如原本已经有一个key会a值为b的localStorage，你再执行："),e("code",[t._v("localStorage.setItem('a', 'b')")]),t._v("代码，同样是不会触发监听函数的.")]),t._v(" "),e("p",[e("strong",[t._v("2.webworker")])]),t._v(" "),e("p",[t._v("普通的webworker直接使用new Worker()即可创建，这种webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的.")]),t._v(" "),e("p",[e("strong",[t._v("SharedWorker")])]),t._v(" "),e("p",[t._v("SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)")]),t._v(" "),e("p",[t._v("新建一个js文件worker.js")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// sharedWorker所要用到的js文件，不必打包到项目中，直接放到服务器即可")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" data "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onconnect")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("e")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" port "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ports"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n  port"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onmessage")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("e")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'get'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      port"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("postMessage")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      data "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("webworker端(暂且这样称呼)的代码就如上，只需注册一个onmessage监听信息的事件，客户端(即使用sharedWorker的标签页)发送message时就会触发.")]),t._v(" "),e("p",[t._v("注意webworker无法在本地使用, worker.js和index.html在同一目录.")]),t._v(" "),e("p",[t._v("index.html")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("// 这段代码是必须的，打开页面后注册SharedWorker，显示指定worker.port.start()方法建立与worker间的连接\n    if (typeof Worker === \"undefined\") {\n      alert('当前浏览器不支持webworker')\n    } else {\n      let worker = new SharedWorker('worker.js')\n      worker.port.addEventListener('message', (e) => {\n        console.log('来自worker的数据：', e.data)\n      }, false)\n      worker.port.start()\n      window.worker = worker\n    }\n// 获取和发送消息都是调用postMessage方法，我这里约定的是传递'get'表示获取数据。\nwindow.worker.port.postMessage('get')\nwindow.worker.port.postMessage('发送信息给worker')\n")])])]),e("h3",{attrs:{id:"原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/js/proto.png")}}),t._v(" "),e("ul",[e("li",[e("code",[t._v("Object")]),t._v(" 是所有对象的爸爸，所有对象都可以通过 "),e("code",[t._v("__proto__")]),t._v(" 找到它")]),t._v(" "),e("li",[e("code",[t._v("Function")]),t._v(" 是所有函数的爸爸，所有函数都可以通过 "),e("code",[t._v("__proto__")]),t._v(" 找到它")]),t._v(" "),e("li",[e("code",[t._v("Function.prototype")]),t._v(" 和 "),e("code",[t._v("Object.prototype")]),t._v(" 是两个特殊的对象，他们由引擎来创建")]),t._v(" "),e("li",[t._v("除了以上两个特殊对象，其他对象都是通过构造器 "),e("code",[t._v("new")]),t._v(" 出来的")]),t._v(" "),e("li",[t._v("函数的 "),e("code",[t._v("prototype")]),t._v(" 是一个对象，也就是原型")]),t._v(" "),e("li",[t._v("对象的 "),e("code",[t._v("__proto__")]),t._v(" 指向原型， "),e("code",[t._v("__proto__")]),t._v(" 将对象和原型连接起来组成了原型链")])]),t._v(" "),e("p",[t._v("先有的 Function.prototype 再有的 function Function , 不像 Foo , 是先有的 function Foo 再有的 Foo.prototype, 所以 Function."),e("strong",[t._v("proto")]),t._v(" === Function.prototype, 这是引擎作出的操作.")]),t._v(" "),e("p",[t._v("bind() 生成的没有 prototype (所以不会影响原来的 function), new 它们的时候, 会调用原构造函数, 将原构造函数的 prototype 赋给 对象的 "),e("strong",[t._v("proto")]),t._v(" .")]),t._v(" "),e("h3",{attrs:{id:"prototype作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prototype作用"}},[t._v("#")]),t._v(" prototype作用")]),t._v(" "),e("ul",[e("li",[t._v("让实例对象知道是什么函数构造了它")]),t._v(" "),e("li",[t._v("如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 "),e("code",[t._v("xx.constructor.method")]),t._v(" 来扩展")])]),t._v(" "),e("h3",{attrs:{id:"new的过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new的过程"}},[t._v("#")]),t._v(" new的过程")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("step1：首先创建一个空对象，这个对象将会作为执行 new 构造函数() 之后，返回的对象实例")])]),t._v(" "),e("li",[e("p",[t._v("step2：将上面创建的空对象的原型（"),e("code",[t._v("__proto__")]),t._v("），指向构造函数的 prototype 属性")])]),t._v(" "),e("li",[e("p",[t._v("step3：将这个空对象赋值给构造函数内部的 this，并执行构造函数逻辑")])]),t._v(" "),e("li",[e("p",[t._v("step4：根据构造函数执行逻辑，返回第一步创建的对象或者构造函数的显式返回值")]),t._v(" "),e("p",[t._v("function newFunc(...args) {\n// 取出 args 数组第一个参数，即目标构造函数\nconst constructor = args.shift()")]),t._v(" "),e("p",[t._v("// 创建一个空对象，且这个空对象继承构造函数的 prototype 属性\n// 即实现 obj."),e("strong",[t._v("proto")]),t._v(" === constructor.prototype\nconst obj = Object.create(constructor.prototype)")]),t._v(" "),e("p",[t._v("// 执行构造函数，得到构造函数返回结果\n// 注意这里我们使用 apply，将构造函数内的 this 指向为 obj\nconst result = constructor.apply(obj, args)")]),t._v(" "),e("p",[t._v("// 如果造函数执行后，返回结果是对象类型，就直接返回，否则返回 obj 对象\nreturn (typeof result === 'object' && result != null) ? result : obj\n}")])])]),t._v(" "),e("h3",{attrs:{id:"this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[t._v("#")]),t._v(" this")]),t._v(" "),e("p",[e("strong",[t._v("this 的指向，是在调用函数时根据执行上下文所动态确定的")])]),t._v(" "),e("ul",[e("li",[t._v("在函数体中，简单调用该函数时（非显式/隐式绑定下），严格模式下 "),e("code",[t._v("this")]),t._v(" 绑定到 "),e("code",[t._v("undefined")]),t._v("，否则绑定到全局对象 "),e("code",[t._v("window")]),t._v("／"),e("code",[t._v("global")]),t._v("；")]),t._v(" "),e("li",[t._v("一般构造函数 "),e("code",[t._v("new")]),t._v(" 调用，绑定到新创建的对象上；")]),t._v(" "),e("li",[t._v("一般由 "),e("code",[t._v("call")]),t._v("/"),e("code",[t._v("apply")]),t._v("/"),e("code",[t._v("bind")]),t._v(" 方法显式调用，绑定到指定参数的对象上；")]),t._v(" "),e("li",[t._v("一般由上下文对象调用，绑定在该对象上；")]),t._v(" "),e("li",[t._v("箭头函数中，根据外层上下文绑定的 "),e("code",[t._v("this")]),t._v(" 决定 "),e("code",[t._v("this")]),t._v(" 指向。")])]),t._v(" "),e("p",[t._v("非严格模式下的 bind call apply 会把 undefined, null 这些context转成全局对象(window, global)\n"),e("img",{attrs:{src:t.$withBase("/js/bind.jpg")}})]),t._v(" "),e("h3",{attrs:{id:"javascript-执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-执行"}},[t._v("#")]),t._v(" JavaScript 执行")]),t._v(" "),e("ul",[e("li",[t._v("代码预编译阶段")]),t._v(" "),e("li",[t._v("代码执行阶段")])]),t._v(" "),e("p",[t._v("预编译阶段是前置阶段，这个时候由编译器将 JavaScript 代码编译成可执行的代码。 注意，这里的预编译和传统的编译并不一样，传统的编译非常复杂，涉及分词、解析、代码生成等过程 。这里的预编译是 JavaScript 中独特的概念，虽然 JavaScript 是解释型语言，编译一行，执行一行。但是在代码执行前，JavaScript 引擎确实会做一些「预先准备工作」")]),t._v(" "),e("p",[e("strong",[t._v("执行阶段主要任务是执行代码，执行上下文在这个阶段全部创建完成")])]),t._v(" "),e("p",[t._v("JavaScript 代码在预编译阶段对变量的内存空间进行分配，我们熟悉的变量提升过程便是在此阶段完成的")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("预编译阶段进行变量声明；")])]),t._v(" "),e("li",[e("p",[t._v("预编译阶段变量声明进行提升，但是值为 undefined；")])]),t._v(" "),e("li",[e("p",[t._v("预编译阶段所有非表达式的函数声明进行提升。")]),t._v(" "),e("p",[t._v("function bar() {\nconsole.log('bar1')\n}")]),t._v(" "),e("p",[t._v("var bar = function () {\nconsole.log('bar2')\n}")]),t._v(" "),e("p",[t._v("bar()")]),t._v(" "),e("p",[t._v("// 输出：bar2，我们调换顺序：")]),t._v(" "),e("p",[t._v("var bar = function () {\nconsole.log('bar2')\n}")]),t._v(" "),e("p",[t._v("function bar() {\nconsole.log('bar1')\n}")]),t._v(" "),e("p",[t._v("bar()\n// 仍然输出：bar2")]),t._v(" "),e("p",[t._v("foo(10)\nfunction foo (num) {\nconsole.log(foo)\nfoo = num;"),e("br"),t._v("\nconsole.log(foo)\nvar foo\n}\nconsole.log(foo)\nfoo = 1\nconsole.log(foo)")]),t._v(" "),e("p",[t._v("输出：")]),t._v(" "),e("p",[t._v("undefined\n10\nƒ foo (num) {\nconsole.log(foo)\nfoo = num"),e("br"),t._v("\nconsole.log(foo)\nvar foo\n}\n1")])])]),t._v(" "),e("p",[t._v("作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完全生成的。因为函数在调用时，才会开始创建对应的执行上下文。")]),t._v(" "),e("p",[e("strong",[t._v("执行上下文")]),t._v("包括了：变量对象、作用域链以及 this 的指向")]),t._v(" "),e("p",[t._v("变量提升是发生在预编译阶段，也就是执行上下文的创建阶段，这个阶段就是：创建变量对象，创建作用域链，确定this指向，let和const的变量是在执行阶段开始执行的，所以没有在预编译阶段执行，就是没有提升."),e("br"),t._v("\nJavaScript引擎在扫描代码时，也就是预编译阶段，对于发现的变量声明，要么将它们提升到作用域顶部，也就是var声明的，要么将声明放在暂时性死区，也就是let和const，在执行阶段时，执行到声明语句后，才会从暂时性死区移除.")]),t._v(" "),e("h3",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),e("p",[t._v("闭包也是一个函数，它也是定义在全局里的，只是它的定义时间是依赖它的包含函数的，之所以闭包能访问外部函数的变量，是因为外部函数内的代码执行，执行到它，它被定义时，它把外部函数的变量对象保存在了自己的"),e("code",[t._v("[[scope]]")]),t._v("属性上."),e("br"),t._v("\n这个内部函数被返回，然后执行时，第一创建自己的执行环境，然后把"),e("code",[t._v("[[scope]]")]),t._v("里保存的作用域复制过来，把自己的变量对象放在最前端，建立自己的作用域链，所以它依然可以访问外部函数的变量，所以无论闭包还是词法环境，搜索变量的过程都是在作用域链上搜索."),e("br"),t._v("\n至于它能搜索到哪些变量，取决于它所在的执行环境，也就是this.")]),t._v(" "),e("h3",{attrs:{id:"内存管理基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存管理基本概念"}},[t._v("#")]),t._v(" 内存管理基本概念")]),t._v(" "),e("ul",[e("li",[t._v("栈空间：由操作系统自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。")]),t._v(" "),e("li",[t._v("堆空间：一般由开发者分配释放，这部分空间就要考虑垃圾回收的问题。")])]),t._v(" "),e("p",[t._v("一般情况下，基本数据类型保存在栈内存当中，引用类型保存在堆内存当中")]),t._v(" "),e("h3",{attrs:{id:"bind"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bind"}},[t._v("#")]),t._v(" bind")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("Function.prototype.bind = Function.prototype.bind || function (context) {\n   var me = this;\n   var args = Array.prototype.slice.call(arguments, 1);\n   var F = function () {}; // 为了不影响原来的 prototype\n   F.prototype = this.prototype;\n   var bound = function () {\n       var innerArgs = Array.prototype.slice.call(arguments);\n       var finalArgs = args.concat(innerArgs);\n       return me.apply(this instanceof F ? this : context || this, finalArgs);\n   }\n   bound.prototype = new F();\n   return bound;\n}\n")])])]),e("h3",{attrs:{id:"apply"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#apply"}},[t._v("#")]),t._v(" apply")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("Function.prototype.applyFn = function (targetObject, argsArray) {\n   if(typeof argsArray === 'undefined' || argsArray === null) {\n       argsArray = []\n   }\n\n   if(typeof targetObject === 'undefined' || targetObject === null){\n       targetObject = window\n   }\n\n   targetObject = new Object(targetObject)\n\n   const targetFnKey = 'targetFnKey'\n   targetObject[targetFnKey] = this\n\n   const result = targetObject[targetFnKey](...argsArray)\n   delete targetObject[targetFnKey]\n   return result\n}\n")])])]),e("h3",{attrs:{id:"reduce"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reduce"}},[t._v("#")]),t._v(" reduce")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("Array.prototype.reduce = Array.prototype.reduce || function(func, initialValue) {\n   var arr = this\n   var base = typeof initialValue === 'undefined' ? arr[0] : initialValue\n   var startPoint = typeof initialValue === 'undefined' ? 1 : 0\n   arr.slice(startPoint)\n       .forEach(function(val, index) {\n           base = func(base, val, index + startPoint, arr)\n       })\n   return base\n}\n")])])]),e("h3",{attrs:{id:"javascript-类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-类型"}},[t._v("#")]),t._v(" JavaScript 类型")]),t._v(" "),e("ul",[e("li",[t._v("null")]),t._v(" "),e("li",[t._v("undefined")]),t._v(" "),e("li",[t._v("boolean")]),t._v(" "),e("li",[t._v("number")]),t._v(" "),e("li",[t._v("string")]),t._v(" "),e("li",[t._v("object")]),t._v(" "),e("li",[t._v("symbol")]),t._v(" "),e("li",[t._v("bigint")])]),t._v(" "),e("p",[t._v("object 类型又具体包含了 function、array、date 等。")]),t._v(" "),e("p",[e("strong",[t._v("使用 typeof 判断类型")])]),t._v(" "),e("p",[t._v("使用 typeof 可以准确判断出除 null 以外的基本类型，以及 function 类型、symbol 类型；null 会被 typeof 判断为 object, bigint 为 bigint。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('const foo = () => 1\ntypeof foo // "function"\n')])])]),e("p",[e("strong",[t._v("使用 instanceof 判断类型")])]),t._v(" "),e("p",[t._v("使用 a instanceof B 判断的是：a 是否为 B 的实例，即 a 的原型链上是否存在 B 构造函数")]),t._v(" "),e("p",[e("strong",[t._v("使用 constructor 和 Object.prototype.toString 判断类型")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("console.log(Object.prototype.toString.call(1))\n// [object Number]\n")])])]),e("h3",{attrs:{id:"转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#转换"}},[t._v("#")]),t._v(" "),e("strong",[t._v("转换")])]),t._v(" "),e("p",[t._v("当使用 + 运算符计算 string 和其他类型相加时，都会转换为 string 类型；其他情况，都会转换为 number 类型，但是 undefined 会转换为 NaN，相加结果也是 NaN")]),t._v(" "),e("p",[e("strong",[t._v("复杂类型")])]),t._v(" "),e("p",[t._v("当使用 + 运算符计算时，如果存在复杂类型，那么复杂类型将会转换为基本类型，再进行运算.")]),t._v(" "),e("p",[t._v("对象在转换基本类型时，会调用该对象上 valueOf 或 toString 这两个方法，该方法的返回值是转换为基本类型的结果.")]),t._v(" "),e("p",[t._v("那具体调用 valueOf 还是 toString 呢？这是 ES 规范所决定的，实际上这取决于内置的 toPrimitive 调用结果.")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('const object1 = {\n  [Symbol.toPrimitive](hint) {\n    if (hint == \'number\') {\n\t\t\t// The hint argument can be one of "number", "string", and "default".\n      return 42;\n    }\n    return null;\n  }\n};\n\nconsole.log(+object1);\n// expected output: 42\n')])])]),e("h4",{attrs:{id:"bigint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bigint"}},[t._v("#")]),t._v(" bigInt")]),t._v(" "),e("p",[t._v("https://mp.weixin.qq.com/s/_jfA25-daJUaY2uIcSeNDg")]),t._v(" "),e("ol",[e("li",[t._v("在整数字面量后面加n。")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" bigIntNum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("9007199254740993n")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("使用 BigInt 函数。")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" bigIntNum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("BigInt")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("9007199254740")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" anOtherBigIntNum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("BigInt")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'9007199254740993'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("通过 BigInt， 我们可以安全的进行大数整型计算。")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" bigNumRet "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("9007199254740993n")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("9007199254740993n")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// -> -> 18014398509481986n")]),t._v("\n\nbigNumRet"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// -> '18014398509481986'")]),t._v("\n")])])]),e("p",[t._v("注意:")]),t._v(" "),e("ol",[e("li",[t._v("BigInt 是一种新的数据原始（primitive）类型。")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("9007199254740993n")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// -> 'bigint'")]),t._v("\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("尽可能避免通过调用函数 BigInt 方式来实例化超大整型。因为参数的字面量实际也是 Number 类型的一次实例化，超出安全范围的数字，可能会引起精度丢失。")])]),t._v(" "),e("h3",{attrs:{id:"promise"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[t._v("#")]),t._v(" Promise")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function Promise(executor) {\n this.status = 'pending'\n this.value = null\n this.reason = null\n this.onFulfilledArray = []\n this.onRejectedArray = []\n\n const resolve = value => {\n   if (value instanceof Promise) {\n     return value.then(resolve, reject)\n   }\n   setTimeout(() => {\n     if (this.status === 'pending') {\n       this.value = value\n       this.status = 'fulfilled'\n\n       this.onFulfilledArray.forEach(func => {\n         func(value)\n       })\n     }\n   })\n }\n\n const reject = reason => {\n   setTimeout(() => {\n     if (this.status === 'pending') {\n       this.reason = reason\n       this.status = 'rejected'\n\n       this.onRejectedArray.forEach(func => {\n         func(reason)\n       })\n     }\n   })\n }\n\n\n   try {\n       executor(resolve, reject)\n   } catch(e) {\n       reject(e)\n   }\n}\n\nconst resolvePromise = (promise2, result, resolve, reject) => {\n // 当 result 和 promise2 相等时，也就是说 onfulfilled 返回 promise2 时，进行 reject\n if (result === promise2) {\n   return reject(new TypeError('error due to circular reference'))\n }\n\n // 是否已经执行过 onfulfilled 或者 onrejected\n let consumed = false\n let thenable\n\n if (result instanceof Promise) {\n   if (result.status === 'pending') {\n     result.then(function(data) {\n       resolvePromise(promise2, data, resolve, reject)\n     }, reject)\n   } else {\n     result.then(resolve, reject)\n   }\n   return\n }\n\n let isComplexResult = target => (typeof target === 'function' || typeof target === 'object') && (target !== null)\n // 如果返回的是疑似 Promise 类型\n if (isComplexResult(result)) {\n   try {\n     thenable = result.then\n     // 如果返回的是 Promise 类型，具有 then 方法\n     if (typeof thenable === 'function') {\n       thenable.call(result, function(data) {\n         if (consumed) {\n           return\n         }\n         consumed = true\n\n         return resolvePromise(promise2, data, resolve, reject)\n       }, function(error) {\n         if (consumed) {\n           return\n         }\n         consumed = true\n\n         return reject(error)\n       })\n     }\n     else {\n       return resolve(result)\n     }\n\n   } catch(e) {\n     if (consumed) {\n       return\n     }\n     consumed = true\n     return reject(e)\n   }\n }\n else {\n   return resolve(result)\n }\n}\n\nPromise.prototype.then = function(onfulfilled, onrejected) {\n onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data\n onrejected = typeof onrejected === 'function' ? onrejected : error => {throw error}\n\n // promise2 将作为 then 方法的返回值\n let promise2\n\n if (this.status === 'fulfilled') {\n   return promise2 = new Promise((resolve, reject) => {\n     setTimeout(() => {\n       try {\n         // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果\n         let result = onfulfilled(this.value)\n         resolvePromise(promise2, result, resolve, reject)\n       }\n       catch(e) {\n         reject(e)\n       }\n     })\n   })\n }\n if (this.status === 'rejected') {\n   return promise2 = new Promise((resolve, reject) => {\n     setTimeout(() => {\n       try {\n         // 这个新的 promise2 reject 的值为 onrejected 的执行结果\n        let result = onrejected(this.reason)\n        resolvePromise(promise2, result, resolve, reject)\n       }\n       catch(e) {\n         reject(e)\n       }\n     })\n   })\n }\n if (this.status === 'pending') {\n   return promise2 = new Promise((resolve, reject) => {\n     this.onFulfilledArray.push(value => {\n       try {\n         let result = onfulfilled(value)\n         resolvePromise(promise2, result, resolve, reject)\n       }\n       catch(e) {\n         return reject(e)\n       }\n     })\n\n     this.onRejectedArray.push(reason => {\n       try {\n         let result = onrejected(reason)\n         resolvePromise(promise2, result, resolve, reject)\n       }\n       catch(e) {\n         return reject(e)\n       }\n     })      \n   })\n }\n}\n\nPromise.prototype.catch = function(catchFunc) {\n return this.then(null, catchFunc)\n}\n\nPromise.resolve = function(value) {\n return new Promise((resolve, reject) => {\n   resolve(value)\n })\n}\n\nPromise.reject = function(value) {\n return new Promise((resolve, reject) => {\n   reject(value)\n })\n}\n\nPromise.race = function(promiseArray) {\n if (!Array.isArray(promiseArray)) {\n     throw new TypeError('The arguments should be an array!')\n }\n return new Promise((resolve, reject) => {\n   try {\n     const length = promiseArray.length\n     for (let i = 0; i        promiseArray[i].then(resolve, reject)\n     }\n   }\n   catch(e) {\n     reject(e)\n   }\n })\n}\n\nPromise.all = function (promiseArray) {\n  if (!Array.isArray(promiseArray)) {\n    throw new TypeError('The arguments should be an array!')\n  }\n  return new Promise((resolve, reject) => {\n    try {\n      let resultArray = []\n      let count = 0\n      const length = promiseArray.length\n\n      for (let i = 0; i < promiseArray.length; i++) {\n        promiseArray[i].then(data => {\n          resultArray[i] = data\n          count++\n\n          if (count === length) {\n            resolve(resultArray)\n          }\n        }, reject)\n      }\n    }\n    catch (e) {\n      reject(e)\n    }\n  })\n}\n")])])]),e("h3",{attrs:{id:"继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function inherit(Child, Parent) {\n    // 继承原型上的属性\n   Child.prototype = Object.create(Parent.prototype)\n\n    // 修复 constructor\n   Child.prototype.constructor = Child\n\n   // 存储超类\n   Child.super = Parent\n\n   // 静态属性继承\n   if (Object.setPrototypeOf) {\n       // setPrototypeOf es6\n       Object.setPrototypeOf(Child, Parent)\n   } else if (Child.__proto__) {\n       // __proto__ es6 引入，但是部分浏览器早已支持\n       Child.__proto__ = Parent\n   } else {\n       // 兼容 IE10 等陈旧浏览器\n       // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法\n       for (var k in Parent) {\n           if (Parent.hasOwnProperty(k) && !(k in Child)) {\n               Child[k] = Parent[k]\n           }\n       }\n   }\n\n}\n")])])]),e("p",[t._v("JavaScript 的日期对象只能通过 JavaScript Date 作为构造函数来实例化得到。")]),t._v(" "),e("p",[e("strong",[t._v("Date继承")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function DateConstructor() {\n   var dateObj = new(Function.prototype.bind.apply(Date, [Date].concat(Array.prototype.slice.call(arguments))))()\n\n   Object.setPrototypeOf(dateObj, DateConstructor.prototype)\n\n   dateObj.foo = 'bar'\n\n   return dateObj\n}\n\nObject.setPrototypeOf(DateConstructor.prototype, Date.prototype)\n\nDateConstructor.prototype.getMyTime = function getTime() {\n   return this.getTime()\n}\n\nlet date = new DateConstructor()\n\nconsole.log(date.getMyTime())\n")])])]),e("p",[t._v("整个实现过程通过更改原型关系，在构造函数里调用原生构造函数 Date，并返回其实例的方法，「欺骗了」浏览器。当然这样的做法比较取巧，其副作用是更改了原型关系，这样也会干扰浏览器某些优化操作。")]),t._v(" "),e("p",[e("strong",[t._v("ES6")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("class DateConstructor extends Date {\n   constructor() {\n       super()\n       this.foo ='bar'\n   }\n   getMyTime() {\n       return this.getTime()\n   }\n}\n\nlet date = new DateConstructor()\n\n// 上面的方法可以完美执行：\n\ndate.getMyTime()\n// 1558921640586\n")])])]),e("h3",{attrs:{id:"async-await"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[t._v("#")]),t._v(" async await")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("async function findPosts() {\n  var response = await $.get('/posts');\n  try{\n     return JSON.parse(response.posts)\n  } catch(e) {\n     throw new Error(\"failed\")\n  }\n}\n")])])]),e("p",[t._v("to")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function findPosts() {\n    var ctx = this, args = arguments;\n    return Promise.resolve().then(function () {\n        var response;\n        return $.get('/posts').then(function (value) {\n            response = value;\n            return Promise.resolve().then(function () {\n                return JSON.parse(response.posts);\n            }).catch(function (e) {\n                throw new Error('failed');\n            }).then(function () {\n            });\n        });\n    });\n}\n")])])]),e("h3",{attrs:{id:"箭头函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[t._v("#")]),t._v(" 箭头函数")]),t._v(" "),e("p",[t._v("没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。")]),t._v(" "),e("h3",{attrs:{id:"类数组转数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类数组转数组"}},[t._v("#")]),t._v(" 类数组转数组")]),t._v(" "),e("p",[t._v("Array.prototype.slice.call()")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("var toArray = function(s){\n\ttry{  \n\t   return Array.prototype.slice.call(s);  \n\t} catch(e){  \n\t  var arr = [];  \n\t  for(var i = 0,len = s.length; i < len; i++){   \n\t       arr[i] = s[i];\n\t\t}\n\t}  \n  return arr;  \n}\n")])])]),e("p",[t._v("Array.from()")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("var args = Array.from(arguments);\n")])])]),e("p",[t._v("扩展运算符（…）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("var args = [...arguments];\n")])])]),e("h3",{attrs:{id:"纯函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#纯函数"}},[t._v("#")]),t._v(" 纯函数")]),t._v(" "),e("ul",[e("li",[t._v("相同输入总是会返回相同的输出。")]),t._v(" "),e("li",[t._v("不产生副作用。")]),t._v(" "),e("li",[t._v("不依赖于外部状态。")])]),t._v(" "),e("p",[t._v("调用一个纯函数，但是不使用其返回值，无意义.")]),t._v(" "),e("h3",{attrs:{id:"副作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#副作用"}},[t._v("#")]),t._v(" "),e("strong",[t._v("副作用")])]),t._v(" "),e("p",[t._v("修改全局变量（函数外的变量），修改参数或改变外部存储")]),t._v(" "),e("h3",{attrs:{id:"柯里化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#柯里化"}},[t._v("#")]),t._v(" 柯里化")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function curry(fn, ...args) {\n  return fn.length <= args.length ? fn(...args) : function(...args1) {\n    return curry(fn, ...args, ...args1)\n  }\n}\n\nfunction plus(a, b, c) {\n  return a + b + c\n}\n\nconsole.log(curry(plus)(1)(2)(3))\n")])])]),e("h3",{attrs:{id:"偏函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#偏函数"}},[t._v("#")]),t._v(" 偏函数")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("function partial (fn, ...args) {\n\treturn fn.bind(null, ...args)\n}\n")])])]),e("h3",{attrs:{id:"proxy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[t._v("#")]),t._v(" Proxy")]),t._v(" "),e("p",[t._v("支持13种拦截操作\n要注意的点: this\nhttps://zh.javascript.info/proxy")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("get(target, propKey, receiver)")]),t._v("：拦截对象属性的读取，比如"),e("code",[t._v("proxy.foo")]),t._v("和"),e("code",[t._v("proxy['foo']")]),t._v("。")]),t._v(" "),e("li",[e("strong",[t._v("set(target, propKey, value, receiver)")]),t._v("：拦截对象属性的设置，比如"),e("code",[t._v("proxy.foo = v")]),t._v("或"),e("code",[t._v("proxy['foo'] = v")]),t._v("，返回一个布尔值。")]),t._v(" "),e("li",[e("strong",[t._v("has(target, propKey)")]),t._v("：拦截"),e("code",[t._v("propKey in proxy")]),t._v("的操作，返回一个布尔值。")]),t._v(" "),e("li",[e("strong",[t._v("deleteProperty(target, propKey)")]),t._v("：拦截"),e("code",[t._v("delete proxy[propKey]")]),t._v("的操作，返回一个布尔值。")]),t._v(" "),e("li",[e("strong",[t._v("ownKeys(target)")]),t._v("：拦截"),e("code",[t._v("Object.getOwnPropertyNames(proxy)")]),t._v("、"),e("code",[t._v("Object.getOwnPropertySymbols(proxy)")]),t._v("、"),e("code",[t._v("Object.keys(proxy)")]),t._v("、"),e("code",[t._v("for...in")]),t._v("循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而"),e("code",[t._v("Object.keys()")]),t._v("的返回结果仅包括目标对象自身的可遍历属性。")]),t._v(" "),e("li",[e("strong",[t._v("getOwnPropertyDescriptor(target, propKey)")]),t._v("：拦截"),e("code",[t._v("Object.getOwnPropertyDescriptor(proxy, propKey)")]),t._v("，返回属性的描述对象。")]),t._v(" "),e("li",[e("strong",[t._v("defineProperty(target, propKey, propDesc)")]),t._v("：拦截"),e("code",[t._v("Object.defineProperty(proxy, propKey, propDesc）")]),t._v("、"),e("code",[t._v("Object.defineProperties(proxy, propDescs)")]),t._v("，返回一个布尔值。")]),t._v(" "),e("li",[e("strong",[t._v("preventExtensions(target)")]),t._v("：拦截"),e("code",[t._v("Object.preventExtensions(proxy)")]),t._v("，返回一个布尔值。")]),t._v(" "),e("li",[e("strong",[t._v("getPrototypeOf(target)")]),t._v("：拦截"),e("code",[t._v("Object.getPrototypeOf(proxy)")]),t._v("，返回一个对象。")]),t._v(" "),e("li",[e("strong",[t._v("isExtensible(target)")]),t._v("：拦截"),e("code",[t._v("Object.isExtensible(proxy)")]),t._v("，返回一个布尔值。")]),t._v(" "),e("li",[e("strong",[t._v("setPrototypeOf(target, proto)")]),t._v("：拦截"),e("code",[t._v("Object.setPrototypeOf(proxy, proto)")]),t._v("，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。")]),t._v(" "),e("li",[e("strong",[t._v("apply(target, object, args)")]),t._v("：拦截 Proxy 实例作为函数调用的操作，比如"),e("code",[t._v("proxy(...args)")]),t._v("、"),e("code",[t._v("proxy.call(object, ...args)")]),t._v("、"),e("code",[t._v("proxy.apply(...)")]),t._v("。")]),t._v(" "),e("li",[e("strong",[t._v("construct(target, args)")]),t._v("：拦截 Proxy 实例作为构造函数调用的操作，比如"),e("code",[t._v("new proxy(...args)")]),t._v("。")])]),t._v(" "),e("h3",{attrs:{id:"globalthis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#globalthis"}},[t._v("#")]),t._v(" globalThis")]),t._v(" "),e("p",[t._v("在 Web 中，可以通过 window、self 或者 frames 取到全局对象，但是在 Web Workers 中只有 self 可以。在 Node.js 中，它们都无法获取，必须使用 global。在松散模式下，可以在函数中返回 this 来获取全局对象，但是在严格模式下 this 会返回 undefined 。")]),t._v(" "),e("h3",{attrs:{id:"单例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单例"}},[t._v("#")]),t._v(" 单例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("let obj = {}\n// 也是单例, 因为在JavaScript创建对象的方式十分灵活, \n// 可以直接通过对象字面量的方式实例化一个对象, \n// 而其他面向对象的语言必须使用类进行实例化\n\nclass SingletonApple {\n  constructor(name, creator, products) {\n    //首次使用构造器实例\n    if (!SingletonApple.instance) {\n      this.name = name;\n      this.creator = creator;\n      this.products = products;\n      //将this挂载到SingletonApple这个类的instance属性上\n      SingletonApple.instance = this;\n    }\n    return SingletonApple.instance;\n  }\n}\n")])])]),e("h3",{attrs:{id:"装饰器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#装饰器"}},[t._v("#")]),t._v(" 装饰器")]),t._v(" "),e("p",[t._v("Object.assign")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("class Math {\n  @log\n  add(a, b) {\n    return a + b;\n  }\n}\n\nfunction log(target, name, descriptor) {\n  var oldValue = descriptor.value;\n\n  descriptor.value = function() {\n    console.log(`Calling ${name} with`, arguments);\n    return oldValue.apply(this, arguments);\n  };\n\n  return descriptor;\n}\n\nconst math = new Math();\n\n// passed parameters should get logged now\nmath.add(2, 4);\n")])])]),e("h3",{attrs:{id:"_0-1-0-2-≠-0-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-0-2-≠-0-3"}},[t._v("#")]),t._v(" 0.1+0.2 ≠ 0.3")]),t._v(" "),e("p",[t._v("64位比特又可分为三个部分：")]),t._v(" "),e("ul",[e("li",[t._v("符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数")]),t._v(" "),e("li",[t._v("指数位E：中间的 11 位存储指数（exponent），用来表示次方数")]),t._v(" "),e("li",[t._v("尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://user-gold-cdn.xitu.io/2018/3/8/16205c88ea806bac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://user-gold-cdn.xitu.io/2018/3/8/16205c88ea806bac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("十进制的0.1和0.2会被转换成二进制的，但是由于浮点数用二进制表示时是无穷的：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("0.1 -> 0.0001 1001 1001 1001...(1100循环)\n0.2 -> 0.0011 0011 0011 0011...(0011循环)\n")])])]),e("p",[t._v("IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持53位二进制位，所以两者相加之后得到二进制为：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("0.0100110011001100110011001100110011001100110011001100\n")])])]),e("p",[t._v("因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了0.30000000000000004。所以在进行算术计算时会产生误差。")]),t._v(" "),e("h3",{attrs:{id:"块级作用域声明函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域声明函数"}},[t._v("#")]),t._v(" 块级作用域声明函数")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  a "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("a")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 重名之后函数声明失效")]),t._v("\n  a "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n  console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nconsole"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ƒ a() {}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 0")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 5")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  a "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("b")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  a "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n  console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nconsole"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 10")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 0")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 0")]),t._v("\n")])])]),e("h3",{attrs:{id:"类私有变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类私有变量"}},[t._v("#")]),t._v(" 类私有变量")]),t._v(" "),e("p",[t._v("#开头")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  #name "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'111'")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);