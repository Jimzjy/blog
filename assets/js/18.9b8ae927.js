(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{354:function(e,t,n){"use strict";n.r(t);var r=n(9),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"多个标签页之间通信的几种方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多个标签页之间通信的几种方法"}},[e._v("#")]),e._v(" 多个标签页之间通信的几种方法")]),e._v(" "),n("p",[n("strong",[e._v("1.localstorage")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("window.onstorage = (e) => {console.log(e)}\n// 或者这样\nwindow.addEventListener('storage', (e) => console.log(e))\n")])])]),n("p",[e._v("onstorage以及storage事件，针对都是"),n("strong",[e._v("非当前页面")]),e._v("对localStorage进行修改时才会触发，当前页面修改localStorage不会触发监听函数。然后就是在对原有的数据的值进行修改时才会触发，比如原本已经有一个key会a值为b的localStorage，你再执行："),n("code",[e._v("localStorage.setItem('a', 'b')")]),e._v("代码，同样是不会触发监听函数的.")]),e._v(" "),n("p",[n("strong",[e._v("2.webworker")])]),e._v(" "),n("p",[e._v("普通的webworker直接使用new Worker()即可创建，这种webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的.")]),e._v(" "),n("p",[n("strong",[e._v("SharedWorker")])]),e._v(" "),n("p",[e._v("SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)")]),e._v(" "),n("p",[e._v("新建一个js文件worker.js")]),e._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// sharedWorker所要用到的js文件，不必打包到项目中，直接放到服务器即可")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" data "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v("''")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("onconnect")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("e")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" port "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("ports"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n\n  port"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("onmessage")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("e")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("data "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("===")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v("'get'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      port"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("postMessage")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("data"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("else")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      data "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("data\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),n("p",[e._v("webworker端(暂且这样称呼)的代码就如上，只需注册一个onmessage监听信息的事件，客户端(即使用sharedWorker的标签页)发送message时就会触发.")]),e._v(" "),n("p",[e._v("注意webworker无法在本地使用, worker.js和index.html在同一目录.")]),e._v(" "),n("p",[e._v("index.html")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("// 这段代码是必须的，打开页面后注册SharedWorker，显示指定worker.port.start()方法建立与worker间的连接\n    if (typeof Worker === \"undefined\") {\n      alert('当前浏览器不支持webworker')\n    } else {\n      let worker = new SharedWorker('worker.js')\n      worker.port.addEventListener('message', (e) => {\n        console.log('来自worker的数据：', e.data)\n      }, false)\n      worker.port.start()\n      window.worker = worker\n    }\n// 获取和发送消息都是调用postMessage方法，我这里约定的是传递'get'表示获取数据。\nwindow.worker.port.postMessage('get')\nwindow.worker.port.postMessage('发送信息给worker')\n")])])]),n("h3",{attrs:{id:"原型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[e._v("#")]),e._v(" 原型")]),e._v(" "),n("img",{attrs:{src:e.$withBase("/js/proto.png")}}),e._v(" "),n("ul",[n("li",[n("code",[e._v("Object")]),e._v(" 是所有对象的爸爸，所有对象都可以通过 "),n("code",[e._v("__proto__")]),e._v(" 找到它")]),e._v(" "),n("li",[n("code",[e._v("Function")]),e._v(" 是所有函数的爸爸，所有函数都可以通过 "),n("code",[e._v("__proto__")]),e._v(" 找到它")]),e._v(" "),n("li",[n("code",[e._v("Function.prototype")]),e._v(" 和 "),n("code",[e._v("Object.prototype")]),e._v(" 是两个特殊的对象，他们由引擎来创建")]),e._v(" "),n("li",[e._v("除了以上两个特殊对象，其他对象都是通过构造器 "),n("code",[e._v("new")]),e._v(" 出来的")]),e._v(" "),n("li",[e._v("函数的 "),n("code",[e._v("prototype")]),e._v(" 是一个对象，也就是原型")]),e._v(" "),n("li",[e._v("对象的 "),n("code",[e._v("__proto__")]),e._v(" 指向原型， "),n("code",[e._v("__proto__")]),e._v(" 将对象和原型连接起来组成了原型链")])]),e._v(" "),n("p",[e._v("先有的 Function.prototype 再有的 function Function , 不像 Foo , 是先有的 function Foo 再有的 Foo.prototype, 所以 Function."),n("strong",[e._v("proto")]),e._v(" === Function.prototype, 这是引擎作出的操作.")]),e._v(" "),n("p",[e._v("bind() 生成的没有 prototype (所以不会影响原来的 function), new 它们的时候, 会调用原构造函数, 将原构造函数的 prototype 赋给 对象的 "),n("strong",[e._v("proto")]),e._v(" .")]),e._v(" "),n("h3",{attrs:{id:"prototype作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prototype作用"}},[e._v("#")]),e._v(" prototype作用")]),e._v(" "),n("ul",[n("li",[e._v("让实例对象知道是什么函数构造了它")]),e._v(" "),n("li",[e._v("如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 "),n("code",[e._v("xx.constructor.method")]),e._v(" 来扩展")])]),e._v(" "),n("h3",{attrs:{id:"new的过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new的过程"}},[e._v("#")]),e._v(" new的过程")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("step1：首先创建一个空对象，这个对象将会作为执行 new 构造函数() 之后，返回的对象实例")])]),e._v(" "),n("li",[n("p",[e._v("step2：将上面创建的空对象的原型（"),n("code",[e._v("__proto__")]),e._v("），指向构造函数的 prototype 属性")])]),e._v(" "),n("li",[n("p",[e._v("step3：将这个空对象赋值给构造函数内部的 this，并执行构造函数逻辑")])]),e._v(" "),n("li",[n("p",[e._v("step4：根据构造函数执行逻辑，返回第一步创建的对象或者构造函数的显式返回值")]),e._v(" "),n("p",[e._v("function newFunc(...args) {\n// 取出 args 数组第一个参数，即目标构造函数\nconst constructor = args.shift()")]),e._v(" "),n("p",[e._v("// 创建一个空对象，且这个空对象继承构造函数的 prototype 属性\n// 即实现 obj."),n("strong",[e._v("proto")]),e._v(" === constructor.prototype\nconst obj = Object.create(constructor.prototype)")]),e._v(" "),n("p",[e._v("// 执行构造函数，得到构造函数返回结果\n// 注意这里我们使用 apply，将构造函数内的 this 指向为 obj\nconst result = constructor.apply(obj, args)")]),e._v(" "),n("p",[e._v("// 如果造函数执行后，返回结果是对象类型，就直接返回，否则返回 obj 对象\nreturn (typeof result === 'object' && result != null) ? result : obj\n}")])])]),e._v(" "),n("h3",{attrs:{id:"this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[e._v("#")]),e._v(" this")]),e._v(" "),n("p",[n("strong",[e._v("this 的指向，是在调用函数时根据执行上下文所动态确定的")])]),e._v(" "),n("ul",[n("li",[e._v("在函数体中，简单调用该函数时（非显式/隐式绑定下），严格模式下 "),n("code",[e._v("this")]),e._v(" 绑定到 "),n("code",[e._v("undefined")]),e._v("，否则绑定到全局对象 "),n("code",[e._v("window")]),e._v("／"),n("code",[e._v("global")]),e._v("；")]),e._v(" "),n("li",[e._v("一般构造函数 "),n("code",[e._v("new")]),e._v(" 调用，绑定到新创建的对象上；")]),e._v(" "),n("li",[e._v("一般由 "),n("code",[e._v("call")]),e._v("/"),n("code",[e._v("apply")]),e._v("/"),n("code",[e._v("bind")]),e._v(" 方法显式调用，绑定到指定参数的对象上；")]),e._v(" "),n("li",[e._v("一般由上下文对象调用，绑定在该对象上；")]),e._v(" "),n("li",[e._v("箭头函数中，根据外层上下文绑定的 "),n("code",[e._v("this")]),e._v(" 决定 "),n("code",[e._v("this")]),e._v(" 指向。")])]),e._v(" "),n("p",[e._v("非严格模式下的 bind call apply 会把 undefined, null 这些context转成全局对象(window, global)\n"),n("img",{attrs:{src:e.$withBase("/js/bind.jpg")}})]),e._v(" "),n("h3",{attrs:{id:"javascript-执行"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-执行"}},[e._v("#")]),e._v(" JavaScript 执行")]),e._v(" "),n("ul",[n("li",[e._v("代码预编译阶段")]),e._v(" "),n("li",[e._v("代码执行阶段")])]),e._v(" "),n("p",[e._v("预编译阶段是前置阶段，这个时候由编译器将 JavaScript 代码编译成可执行的代码。 注意，这里的预编译和传统的编译并不一样，传统的编译非常复杂，涉及分词、解析、代码生成等过程 。这里的预编译是 JavaScript 中独特的概念，虽然 JavaScript 是解释型语言，编译一行，执行一行。但是在代码执行前，JavaScript 引擎确实会做一些「预先准备工作」")]),e._v(" "),n("p",[n("strong",[e._v("执行阶段主要任务是执行代码，执行上下文在这个阶段全部创建完成")])]),e._v(" "),n("p",[e._v("JavaScript 代码在预编译阶段对变量的内存空间进行分配，我们熟悉的变量提升过程便是在此阶段完成的")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("预编译阶段进行变量声明；")])]),e._v(" "),n("li",[n("p",[e._v("预编译阶段变量声明进行提升，但是值为 undefined；")])]),e._v(" "),n("li",[n("p",[e._v("预编译阶段所有非表达式的函数声明进行提升。")]),e._v(" "),n("p",[e._v("function bar() {\nconsole.log('bar1')\n}")]),e._v(" "),n("p",[e._v("var bar = function () {\nconsole.log('bar2')\n}")]),e._v(" "),n("p",[e._v("bar()")]),e._v(" "),n("p",[e._v("// 输出：bar2，我们调换顺序：")]),e._v(" "),n("p",[e._v("var bar = function () {\nconsole.log('bar2')\n}")]),e._v(" "),n("p",[e._v("function bar() {\nconsole.log('bar1')\n}")]),e._v(" "),n("p",[e._v("bar()\n// 仍然输出：bar2")]),e._v(" "),n("p",[e._v("foo(10)\nfunction foo (num) {\nconsole.log(foo)\nfoo = num;"),n("br"),e._v("\nconsole.log(foo)\nvar foo\n}\nconsole.log(foo)\nfoo = 1\nconsole.log(foo)")]),e._v(" "),n("p",[e._v("输出：")]),e._v(" "),n("p",[e._v("undefined\n10\nƒ foo (num) {\nconsole.log(foo)\nfoo = num"),n("br"),e._v("\nconsole.log(foo)\nvar foo\n}\n1")])])]),e._v(" "),n("p",[e._v("作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完全生成的。因为函数在调用时，才会开始创建对应的执行上下文。")]),e._v(" "),n("p",[n("strong",[e._v("执行上下文")]),e._v("包括了：变量对象、作用域链以及 this 的指向")]),e._v(" "),n("p",[e._v("变量提升是发生在预编译阶段，也就是执行上下文的创建阶段，这个阶段就是：创建变量对象，创建作用域链，确定this指向，let和const的变量是在执行阶段开始执行的，所以没有在预编译阶段执行，就是没有提升."),n("br"),e._v("\nJavaScript引擎在扫描代码时，也就是预编译阶段，对于发现的变量声明，要么将它们提升到作用域顶部，也就是var声明的，要么将声明放在暂时性死区，也就是let和const，在执行阶段时，执行到声明语句后，才会从暂时性死区移除.")]),e._v(" "),n("h3",{attrs:{id:"闭包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[e._v("#")]),e._v(" 闭包")]),e._v(" "),n("p",[e._v("闭包也是一个函数，它也是定义在全局里的，只是它的定义时间是依赖它的包含函数的，之所以闭包能访问外部函数的变量，是因为外部函数内的代码执行，执行到它，它被定义时，它把外部函数的变量对象保存在了自己的"),n("code",[e._v("[[scope]]")]),e._v("属性上."),n("br"),e._v("\n这个内部函数被返回，然后执行时，第一创建自己的执行环境，然后把"),n("code",[e._v("[[scope]]")]),e._v("里保存的作用域复制过来，把自己的变量对象放在最前端，建立自己的作用域链，所以它依然可以访问外部函数的变量，所以无论闭包还是词法环境，搜索变量的过程都是在作用域链上搜索."),n("br"),e._v("\n至于它能搜索到哪些变量，取决于它所在的执行环境，也就是this.")]),e._v(" "),n("h3",{attrs:{id:"内存管理基本概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存管理基本概念"}},[e._v("#")]),e._v(" 内存管理基本概念")]),e._v(" "),n("ul",[n("li",[e._v("栈空间：由操作系统自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。")]),e._v(" "),n("li",[e._v("堆空间：一般由开发者分配释放，这部分空间就要考虑垃圾回收的问题。")])]),e._v(" "),n("p",[e._v("一般情况下，基本数据类型保存在栈内存当中，引用类型保存在堆内存当中")]),e._v(" "),n("h3",{attrs:{id:"bind"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bind"}},[e._v("#")]),e._v(" bind")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("Function.prototype.bind = Function.prototype.bind || function (context) {\n   var me = this;\n   var args = Array.prototype.slice.call(arguments, 1);\n   var F = function () {}; // 为了不影响原来的 prototype\n   F.prototype = this.prototype;\n   var bound = function () {\n       var innerArgs = Array.prototype.slice.call(arguments);\n       var finalArgs = args.concat(innerArgs);\n       return me.apply(this instanceof F ? this : context || this, finalArgs);\n   }\n   bound.prototype = new F();\n   return bound;\n}\n")])])]),n("h3",{attrs:{id:"apply"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#apply"}},[e._v("#")]),e._v(" apply")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("Function.prototype.applyFn = function (targetObject, argsArray) {\n   if(typeof argsArray === 'undefined' || argsArray === null) {\n       argsArray = []\n   }\n\n   if(typeof targetObject === 'undefined' || targetObject === null){\n       targetObject = window\n   }\n\n   targetObject = new Object(targetObject)\n\n   const targetFnKey = 'targetFnKey'\n   targetObject[targetFnKey] = this\n\n   const result = targetObject[targetFnKey](...argsArray)\n   delete targetObject[targetFnKey]\n   return result\n}\n")])])]),n("h3",{attrs:{id:"reduce"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reduce"}},[e._v("#")]),e._v(" reduce")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("Array.prototype.reduce = Array.prototype.reduce || function(func, initialValue) {\n   var arr = this\n   var base = typeof initialValue === 'undefined' ? arr[0] : initialValue\n   var startPoint = typeof initialValue === 'undefined' ? 1 : 0\n   arr.slice(startPoint)\n       .forEach(function(val, index) {\n           base = func(base, val, index + startPoint, arr)\n       })\n   return base\n}\n")])])]),n("h3",{attrs:{id:"javascript-类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-类型"}},[e._v("#")]),e._v(" JavaScript 类型")]),e._v(" "),n("ul",[n("li",[e._v("null")]),e._v(" "),n("li",[e._v("undefined")]),e._v(" "),n("li",[e._v("boolean")]),e._v(" "),n("li",[e._v("number")]),e._v(" "),n("li",[e._v("string")]),e._v(" "),n("li",[e._v("object")]),e._v(" "),n("li",[e._v("symbol")]),e._v(" "),n("li",[e._v("bigint")])]),e._v(" "),n("p",[e._v("object 类型又具体包含了 function、array、date 等。")]),e._v(" "),n("p",[n("strong",[e._v("使用 typeof 判断类型")])]),e._v(" "),n("p",[e._v("使用 typeof 可以准确判断出除 null 以外的基本类型，以及 function 类型、symbol 类型；null 会被 typeof 判断为 object, bigint 为 bigint。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('const foo = () => 1\ntypeof foo // "function"\n')])])]),n("p",[n("strong",[e._v("使用 instanceof 判断类型")])]),e._v(" "),n("p",[e._v("使用 a instanceof B 判断的是：a 是否为 B 的实例，即 a 的原型链上是否存在 B 构造函数")]),e._v(" "),n("p",[n("strong",[e._v("使用 constructor 和 Object.prototype.toString 判断类型")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("console.log(Object.prototype.toString.call(1))\n// [object Number]\n")])])]),n("h3",{attrs:{id:"转换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#转换"}},[e._v("#")]),e._v(" "),n("strong",[e._v("转换")])]),e._v(" "),n("p",[e._v("当使用 + 运算符计算 string 和其他类型相加时，都会转换为 string 类型；其他情况，都会转换为 number 类型，但是 undefined 会转换为 NaN，相加结果也是 NaN")]),e._v(" "),n("p",[n("strong",[e._v("复杂类型")])]),e._v(" "),n("p",[e._v("当使用 + 运算符计算时，如果存在复杂类型，那么复杂类型将会转换为基本类型，再进行运算.")]),e._v(" "),n("p",[e._v("对象在转换基本类型时，会调用该对象上 valueOf 或 toString 这两个方法，该方法的返回值是转换为基本类型的结果.")]),e._v(" "),n("p",[e._v("那具体调用 valueOf 还是 toString 呢？这是 ES 规范所决定的，实际上这取决于内置的 toPrimitive 调用结果.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('const object1 = {\n  [Symbol.toPrimitive](hint) {\n    if (hint == \'number\') {\n\t\t\t// The hint argument can be one of "number", "string", and "default".\n      return 42;\n    }\n    return null;\n  }\n};\n\nconsole.log(+object1);\n// expected output: 42\n')])])]),n("h3",{attrs:{id:"promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("function Promise(executor) {\n this.status = 'pending'\n this.value = null\n this.reason = null\n this.onFulfilledArray = []\n this.onRejectedArray = []\n\n const resolve = value => {\n   if (value instanceof Promise) {\n     return value.then(resolve, reject)\n   }\n   setTimeout(() => {\n     if (this.status === 'pending') {\n       this.value = value\n       this.status = 'fulfilled'\n\n       this.onFulfilledArray.forEach(func => {\n         func(value)\n       })\n     }\n   })\n }\n\n const reject = reason => {\n   setTimeout(() => {\n     if (this.status === 'pending') {\n       this.reason = reason\n       this.status = 'rejected'\n\n       this.onRejectedArray.forEach(func => {\n         func(reason)\n       })\n     }\n   })\n }\n\n\n   try {\n       executor(resolve, reject)\n   } catch(e) {\n       reject(e)\n   }\n}\n\nconst resolvePromise = (promise2, result, resolve, reject) => {\n // 当 result 和 promise2 相等时，也就是说 onfulfilled 返回 promise2 时，进行 reject\n if (result === promise2) {\n   return reject(new TypeError('error due to circular reference'))\n }\n\n // 是否已经执行过 onfulfilled 或者 onrejected\n let consumed = false\n let thenable\n\n if (result instanceof Promise) {\n   if (result.status === 'pending') {\n     result.then(function(data) {\n       resolvePromise(promise2, data, resolve, reject)\n     }, reject)\n   } else {\n     result.then(resolve, reject)\n   }\n   return\n }\n\n let isComplexResult = target => (typeof target === 'function' || typeof target === 'object') && (target !== null)\n // 如果返回的是疑似 Promise 类型\n if (isComplexResult(result)) {\n   try {\n     thenable = result.then\n     // 如果返回的是 Promise 类型，具有 then 方法\n     if (typeof thenable === 'function') {\n       thenable.call(result, function(data) {\n         if (consumed) {\n           return\n         }\n         consumed = true\n\n         return resolvePromise(promise2, data, resolve, reject)\n       }, function(error) {\n         if (consumed) {\n           return\n         }\n         consumed = true\n\n         return reject(error)\n       })\n     }\n     else {\n       return resolve(result)\n     }\n\n   } catch(e) {\n     if (consumed) {\n       return\n     }\n     consumed = true\n     return reject(e)\n   }\n }\n else {\n   return resolve(result)\n }\n}\n\nPromise.prototype.then = function(onfulfilled, onrejected) {\n onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : data => data\n onrejected = typeof onrejected === 'function' ? onrejected : error => {throw error}\n\n // promise2 将作为 then 方法的返回值\n let promise2\n\n if (this.status === 'fulfilled') {\n   return promise2 = new Promise((resolve, reject) => {\n     setTimeout(() => {\n       try {\n         // 这个新的 promise2 resolved 的值为 onfulfilled 的执行结果\n         let result = onfulfilled(this.value)\n         resolvePromise(promise2, result, resolve, reject)\n       }\n       catch(e) {\n         reject(e)\n       }\n     })\n   })\n }\n if (this.status === 'rejected') {\n   return promise2 = new Promise((resolve, reject) => {\n     setTimeout(() => {\n       try {\n         // 这个新的 promise2 reject 的值为 onrejected 的执行结果\n        let result = onrejected(this.reason)\n        resolvePromise(promise2, result, resolve, reject)\n       }\n       catch(e) {\n         reject(e)\n       }\n     })\n   })\n }\n if (this.status === 'pending') {\n   return promise2 = new Promise((resolve, reject) => {\n     this.onFulfilledArray.push(value => {\n       try {\n         let result = onfulfilled(value)\n         resolvePromise(promise2, result, resolve, reject)\n       }\n       catch(e) {\n         return reject(e)\n       }\n     })\n\n     this.onRejectedArray.push(reason => {\n       try {\n         let result = onrejected(reason)\n         resolvePromise(promise2, result, resolve, reject)\n       }\n       catch(e) {\n         return reject(e)\n       }\n     })      \n   })\n }\n}\n\nPromise.prototype.catch = function(catchFunc) {\n return this.then(null, catchFunc)\n}\n\nPromise.resolve = function(value) {\n return new Promise((resolve, reject) => {\n   resolve(value)\n })\n}\n\nPromise.reject = function(value) {\n return new Promise((resolve, reject) => {\n   reject(value)\n })\n}\n\nPromise.race = function(promiseArray) {\n if (!Array.isArray(promiseArray)) {\n     throw new TypeError('The arguments should be an array!')\n }\n return new Promise((resolve, reject) => {\n   try {\n     const length = promiseArray.length\n     for (let i = 0; i        promiseArray[i].then(resolve, reject)\n     }\n   }\n   catch(e) {\n     reject(e)\n   }\n })\n}\n\nPromise.all = function (promiseArray) {\n  if (!Array.isArray(promiseArray)) {\n    throw new TypeError('The arguments should be an array!')\n  }\n  return new Promise((resolve, reject) => {\n    try {\n      let resultArray = []\n      let count = 0\n      const length = promiseArray.length\n\n      for (let i = 0; i < promiseArray.length; i++) {\n        promiseArray[i].then(data => {\n          resultArray[i] = data\n          count++\n\n          if (count === length) {\n            resolve(resultArray)\n          }\n        }, reject)\n      }\n    }\n    catch (e) {\n      reject(e)\n    }\n  })\n}\n")])])]),n("h3",{attrs:{id:"继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[e._v("#")]),e._v(" 继承")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("function inherit(Child, Parent) {\n    // 继承原型上的属性\n   Child.prototype = Object.create(Parent.prototype)\n\n    // 修复 constructor\n   Child.prototype.constructor = Child\n\n   // 存储超类\n   Child.super = Parent\n\n   // 静态属性继承\n   if (Object.setPrototypeOf) {\n       // setPrototypeOf es6\n       Object.setPrototypeOf(Child, Parent)\n   } else if (Child.__proto__) {\n       // __proto__ es6 引入，但是部分浏览器早已支持\n       Child.__proto__ = Parent\n   } else {\n       // 兼容 IE10 等陈旧浏览器\n       // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法\n       for (var k in Parent) {\n           if (Parent.hasOwnProperty(k) && !(k in Child)) {\n               Child[k] = Parent[k]\n           }\n       }\n   }\n\n}\n")])])]),n("p",[e._v("JavaScript 的日期对象只能通过 JavaScript Date 作为构造函数来实例化得到。")]),e._v(" "),n("p",[n("strong",[e._v("Date继承")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("function DateConstructor() {\n   var dateObj = new(Function.prototype.bind.apply(Date, [Date].concat(Array.prototype.slice.call(arguments))))()\n\n   Object.setPrototypeOf(dateObj, DateConstructor.prototype)\n\n   dateObj.foo = 'bar'\n\n   return dateObj\n}\n\nObject.setPrototypeOf(DateConstructor.prototype, Date.prototype)\n\nDateConstructor.prototype.getMyTime = function getTime() {\n   return this.getTime()\n}\n\nlet date = new DateConstructor()\n\nconsole.log(date.getMyTime())\n")])])]),n("p",[e._v("整个实现过程通过更改原型关系，在构造函数里调用原生构造函数 Date，并返回其实例的方法，「欺骗了」浏览器。当然这样的做法比较取巧，其副作用是更改了原型关系，这样也会干扰浏览器某些优化操作。")]),e._v(" "),n("p",[n("strong",[e._v("ES6")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("class DateConstructor extends Date {\n   constructor() {\n       super()\n       this.foo ='bar'\n   }\n   getMyTime() {\n       return this.getTime()\n   }\n}\n\nlet date = new DateConstructor()\n\n// 上面的方法可以完美执行：\n\ndate.getMyTime()\n// 1558921640586\n")])])]),n("h3",{attrs:{id:"async-await"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[e._v("#")]),e._v(" async await")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("async function findPosts() {\n  var response = await $.get('/posts');\n  try{\n     return JSON.parse(response.posts)\n  } catch(e) {\n     throw new Error(\"failed\")\n  }\n}\n")])])]),n("p",[e._v("to")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("function findPosts() {\n    var ctx = this, args = arguments;\n    return Promise.resolve().then(function () {\n        var response;\n        return $.get('/posts').then(function (value) {\n            response = value;\n            return Promise.resolve().then(function () {\n                return JSON.parse(response.posts);\n            }).catch(function (e) {\n                throw new Error('failed');\n            }).then(function () {\n            });\n        });\n    });\n}\n")])])]),n("h3",{attrs:{id:"箭头函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[e._v("#")]),e._v(" 箭头函数")]),e._v(" "),n("p",[e._v("没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。")]),e._v(" "),n("h3",{attrs:{id:"类数组转数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类数组转数组"}},[e._v("#")]),e._v(" 类数组转数组")]),e._v(" "),n("p",[e._v("Array.prototype.slice.call()")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("var toArray = function(s){\n\ttry{  \n\t   return Array.prototype.slice.call(s);  \n\t} catch(e){  \n\t  var arr = [];  \n\t  for(var i = 0,len = s.length; i < len; i++){   \n\t       arr[i] = s[i];\n\t\t}\n\t}  \n  return arr;  \n}\n")])])]),n("p",[e._v("Array.from()")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("var args = Array.from(arguments);\n")])])]),n("p",[e._v("扩展运算符（…）")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("var args = [...arguments];\n")])])]),n("h3",{attrs:{id:"纯函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#纯函数"}},[e._v("#")]),e._v(" 纯函数")]),e._v(" "),n("ul",[n("li",[e._v("相同输入总是会返回相同的输出。")]),e._v(" "),n("li",[e._v("不产生副作用。")]),e._v(" "),n("li",[e._v("不依赖于外部状态。")])]),e._v(" "),n("p",[e._v("调用一个纯函数，但是不使用其返回值，无意义.")]),e._v(" "),n("h3",{attrs:{id:"副作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#副作用"}},[e._v("#")]),e._v(" "),n("strong",[e._v("副作用")])]),e._v(" "),n("p",[e._v("修改全局变量（函数外的变量），修改参数或改变外部存储")]),e._v(" "),n("h3",{attrs:{id:"柯里化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#柯里化"}},[e._v("#")]),e._v(" 柯里化")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("function curry(fn, ...args) {\n  return fn.length <= args.length ? fn(...args) : function(...args1) {\n    return curry(fn, ...args, ...args1)\n  }\n}\n\nfunction plus(a, b, c) {\n  return a + b + c\n}\n\nconsole.log(curry(plus)(1)(2)(3))\n")])])]),n("h3",{attrs:{id:"偏函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#偏函数"}},[e._v("#")]),e._v(" 偏函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("function partial (fn, ...args) {\n\treturn fn.bind(null, ...args)\n}\n")])])]),n("h3",{attrs:{id:"proxy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[e._v("#")]),e._v(" Proxy")]),e._v(" "),n("p",[e._v("支持13种拦截操作")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("get(target, propKey, receiver)")]),e._v("：拦截对象属性的读取，比如"),n("code",[e._v("proxy.foo")]),e._v("和"),n("code",[e._v("proxy['foo']")]),e._v("。")]),e._v(" "),n("li",[n("strong",[e._v("set(target, propKey, value, receiver)")]),e._v("：拦截对象属性的设置，比如"),n("code",[e._v("proxy.foo = v")]),e._v("或"),n("code",[e._v("proxy['foo'] = v")]),e._v("，返回一个布尔值。")]),e._v(" "),n("li",[n("strong",[e._v("has(target, propKey)")]),e._v("：拦截"),n("code",[e._v("propKey in proxy")]),e._v("的操作，返回一个布尔值。")]),e._v(" "),n("li",[n("strong",[e._v("deleteProperty(target, propKey)")]),e._v("：拦截"),n("code",[e._v("delete proxy[propKey]")]),e._v("的操作，返回一个布尔值。")]),e._v(" "),n("li",[n("strong",[e._v("ownKeys(target)")]),e._v("：拦截"),n("code",[e._v("Object.getOwnPropertyNames(proxy)")]),e._v("、"),n("code",[e._v("Object.getOwnPropertySymbols(proxy)")]),e._v("、"),n("code",[e._v("Object.keys(proxy)")]),e._v("、"),n("code",[e._v("for...in")]),e._v("循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而"),n("code",[e._v("Object.keys()")]),e._v("的返回结果仅包括目标对象自身的可遍历属性。")]),e._v(" "),n("li",[n("strong",[e._v("getOwnPropertyDescriptor(target, propKey)")]),e._v("：拦截"),n("code",[e._v("Object.getOwnPropertyDescriptor(proxy, propKey)")]),e._v("，返回属性的描述对象。")]),e._v(" "),n("li",[n("strong",[e._v("defineProperty(target, propKey, propDesc)")]),e._v("：拦截"),n("code",[e._v("Object.defineProperty(proxy, propKey, propDesc）")]),e._v("、"),n("code",[e._v("Object.defineProperties(proxy, propDescs)")]),e._v("，返回一个布尔值。")]),e._v(" "),n("li",[n("strong",[e._v("preventExtensions(target)")]),e._v("：拦截"),n("code",[e._v("Object.preventExtensions(proxy)")]),e._v("，返回一个布尔值。")]),e._v(" "),n("li",[n("strong",[e._v("getPrototypeOf(target)")]),e._v("：拦截"),n("code",[e._v("Object.getPrototypeOf(proxy)")]),e._v("，返回一个对象。")]),e._v(" "),n("li",[n("strong",[e._v("isExtensible(target)")]),e._v("：拦截"),n("code",[e._v("Object.isExtensible(proxy)")]),e._v("，返回一个布尔值。")]),e._v(" "),n("li",[n("strong",[e._v("setPrototypeOf(target, proto)")]),e._v("：拦截"),n("code",[e._v("Object.setPrototypeOf(proxy, proto)")]),e._v("，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。")]),e._v(" "),n("li",[n("strong",[e._v("apply(target, object, args)")]),e._v("：拦截 Proxy 实例作为函数调用的操作，比如"),n("code",[e._v("proxy(...args)")]),e._v("、"),n("code",[e._v("proxy.call(object, ...args)")]),e._v("、"),n("code",[e._v("proxy.apply(...)")]),e._v("。")]),e._v(" "),n("li",[n("strong",[e._v("construct(target, args)")]),e._v("：拦截 Proxy 实例作为构造函数调用的操作，比如"),n("code",[e._v("new proxy(...args)")]),e._v("。")])]),e._v(" "),n("h3",{attrs:{id:"globalthis"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#globalthis"}},[e._v("#")]),e._v(" globalThis")]),e._v(" "),n("p",[e._v("在 Web 中，可以通过 window、self 或者 frames 取到全局对象，但是在 Web Workers 中只有 self 可以。在 Node.js 中，它们都无法获取，必须使用 global。在松散模式下，可以在函数中返回 this 来获取全局对象，但是在严格模式下 this 会返回 undefined 。")]),e._v(" "),n("h3",{attrs:{id:"单例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#单例"}},[e._v("#")]),e._v(" 单例")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("let obj = {}\n// 也是单例, 因为在JavaScript创建对象的方式十分灵活, \n// 可以直接通过对象字面量的方式实例化一个对象, \n// 而其他面向对象的语言必须使用类进行实例化\n\nclass SingletonApple {\n  constructor(name, creator, products) {\n    //首次使用构造器实例\n    if (!SingletonApple.instance) {\n      this.name = name;\n      this.creator = creator;\n      this.products = products;\n      //将this挂载到SingletonApple这个类的instance属性上\n      SingletonApple.instance = this;\n    }\n    return SingletonApple.instance;\n  }\n}\n")])])]),n("h3",{attrs:{id:"装饰器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#装饰器"}},[e._v("#")]),e._v(" 装饰器")]),e._v(" "),n("p",[e._v("Object.assign")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("class Math {\n  @log\n  add(a, b) {\n    return a + b;\n  }\n}\n\nfunction log(target, name, descriptor) {\n  var oldValue = descriptor.value;\n\n  descriptor.value = function() {\n    console.log(`Calling ${name} with`, arguments);\n    return oldValue.apply(this, arguments);\n  };\n\n  return descriptor;\n}\n\nconst math = new Math();\n\n// passed parameters should get logged now\nmath.add(2, 4);\n")])])]),n("h3",{attrs:{id:"_0-1-0-2-≠-0-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-0-2-≠-0-3"}},[e._v("#")]),e._v(" 0.1+0.2 ≠ 0.3")]),e._v(" "),n("p",[e._v("64位比特又可分为三个部分：")]),e._v(" "),n("ul",[n("li",[e._v("符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数")]),e._v(" "),n("li",[e._v("指数位E：中间的 11 位存储指数（exponent），用来表示次方数")]),e._v(" "),n("li",[e._v("尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零")])]),e._v(" "),n("p",[n("a",{attrs:{href:"https://user-gold-cdn.xitu.io/2018/3/8/16205c88ea806bac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://user-gold-cdn.xitu.io/2018/3/8/16205c88ea806bac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("十进制的0.1和0.2会被转换成二进制的，但是由于浮点数用二进制表示时是无穷的：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("0.1 -> 0.0001 1001 1001 1001...(1100循环)\n0.2 -> 0.0011 0011 0011 0011...(0011循环)\n")])])]),n("p",[e._v("IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持53位二进制位，所以两者相加之后得到二进制为：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("0.0100110011001100110011001100110011001100110011001100\n")])])]),n("p",[e._v("因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了0.30000000000000004。所以在进行算术计算时会产生误差。")])])}),[],!1,null,null,null);t.default=a.exports}}]);