(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{356:function(e,t,n){"use strict";n.r(t);var v=n(9),s=Object(v.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"node-js"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#node-js"}},[e._v("#")]),e._v(" Node.js")]),e._v(" "),n("h2",{attrs:{id:"eventloop"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[e._v("#")]),e._v(" EventLoop")]),e._v(" "),n("img",{attrs:{src:e.$withBase("/node/event-loop.png")}}),e._v(" "),n("ol",[n("li",[e._v("执行 "),n("code",[e._v("定时器回调")]),e._v(" 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它"),n("code",[e._v("timer")]),e._v("。")]),e._v(" "),n("li",[e._v("轮询(英文叫"),n("code",[e._v("poll")]),e._v(")阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过'data'、 'connect'等事件使得事件循环到达 "),n("code",[e._v("poll")]),e._v(" 阶段。到达了这个阶段后:")])]),e._v(" "),n("p",[e._v("如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。")]),e._v(" "),n("p",[e._v("如果没有定时器, 会去看回调函数队列。")]),e._v(" "),n("ul",[n("li",[e._v("如果队列"),n("code",[e._v("不为空")]),e._v("，拿出队列中的方法依次执行")]),e._v(" "),n("li",[e._v("如果队列"),n("code",[e._v("为空")]),e._v("，检查是否有 "),n("code",[e._v("setImmdiate")]),e._v(" 的回调\n"),n("ul",[n("li",[e._v("有则前往"),n("code",[e._v("check阶段")]),e._v("(下面会说)")]),e._v(" "),n("li",[n("code",[e._v("没有则继续等待")]),e._v("，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后"),n("code",[e._v("自动进入 check 阶段")]),e._v("。")])])])]),e._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[n("p",[e._v("check 阶段。这是一个比较简单的阶段，直接"),n("code",[e._v("执行 setImmdiate")]),e._v(" 的回调。")])]),e._v(" "),n("li",[n("p",[e._v("timer 阶段")])]),e._v(" "),n("li",[n("p",[e._v("I/O 异常回调阶段")])]),e._v(" "),n("li",[n("p",[e._v("空闲、预备状态(第2阶段结束，poll 未触发之前)")])]),e._v(" "),n("li",[n("p",[e._v("poll 阶段")])]),e._v(" "),n("li",[n("p",[e._v("check 阶段")])]),e._v(" "),n("li",[n("p",[e._v("关闭事件的回调阶段")])])]),e._v(" "),n("p",[e._v("浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。")]),e._v(" "),n("h2",{attrs:{id:"process-nexttick"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#process-nexttick"}},[e._v("#")]),e._v(" process.nextTick")]),e._v(" "),n("p",[e._v("process.nextTick 是一个独立于 eventLoop 的任务队列。")]),e._v(" "),n("p",[e._v("在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务"),n("code",[e._v("优先于微任务")]),e._v("执行。")]),e._v(" "),n("h2",{attrs:{id:"eventemitter"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#eventemitter"}},[e._v("#")]),e._v(" EventEmitter")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("class EventEmitter {\n  constructor() {\n    this.map = {}\n  }\n\n  addListener(event, listener) {\n    this.map[event] ? this.map[event].push(listener) : this.map[event] = [listener]\n  }\n\n\tremoveListener(event, listener) {\n    if (this.map[event]) {\n      const _listeners = this.map[event]\n      for (let i = 0; i < _listeners.length; i++) {\n        if (_listeners[i] === listener) {\n          this.map[event].splice(i, 1)\n          return\n        }\n      }\n    }\n  }\n\n  emit(event, data) {\n    if (this.map[event]) this.map[event].forEach(cb => cb(data))\n  }\n\n  once(event, listener) {\n    this.on(event, (data) => {\n      listener(data)\n      this.removeListener(event)\n    })\n  }\n}")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);