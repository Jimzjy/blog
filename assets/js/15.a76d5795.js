(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{353:function(v,e,_){"use strict";_.r(e);var t=_(9),o=Object(t.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"执行过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行过程"}},[v._v("#")]),v._v(" 执行过程")]),v._v(" "),_("p",[_("strong",[v._v("加载：")]),v._v(" 根据请求的url进行域名解析，然后向服务器发送请求，接收响应文件（如HTML、CSS、JS、图片等）.")]),v._v(" "),_("p",[_("strong",[v._v("解析：")]),v._v(" 对加载到的资源（HTML、CSS、JS等）进行语法解析，构建响应的内部数据结构（如HTML的DOM树，JS对象的属性表，css样式规则等）.")]),v._v(" "),_("p",[_("strong",[v._v("渲染：")]),v._v(" 构建渲染树，对各个元素进行位置计算、样式计算等，然后根据渲染书完成页面的布局及绘制的过程（产生页面的元素）.")]),v._v(" "),_("ol",[_("li",[v._v("解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件")]),v._v(" "),_("li",[v._v("CSS 文件下载完成,解析 CSS 文件成树形的数据结构,然后结合 DOM 树合并成 RenderObject 树")]),v._v(" "),_("li",[v._v("布局 RenderObject 树 （Layout/reflow）,负责 RenderObject 树中的元素的尺寸,位置等计算")]),v._v(" "),_("li",[v._v("绘制 RenderObject 树 （paint）,绘制页面的像素信息")]),v._v(" "),_("li",[v._v("浏览器主进程将默认的图层和复合图层交给 GPU 进程,GPU 进程再将各个图层合成（composite）,最后显示出页面")])]),v._v(" "),_("img",{attrs:{src:v.$withBase("/broswer/run.png"),alt:"run"}}),v._v(" "),_("h3",{attrs:{id:"浏览器线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器线程"}},[v._v("#")]),v._v(" 浏览器线程")]),v._v(" "),_("p",[v._v("浏览器是拥有多个线程的比如：gui渲染线程、JS引擎线程、事件触发线程、异步http请求线程")]),v._v(" "),_("h3",{attrs:{id:"event-loop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#event-loop"}},[v._v("#")]),v._v(" Event Loop")]),v._v(" "),_("p",[_("strong",[v._v("JavaScript的运行机制")])]),v._v(" "),_("p",[v._v("（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。")]),v._v(" "),_("p",[v._v('（2）主线程之外，还存在"任务队列"(task queue)。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。')]),v._v(" "),_("p",[v._v('（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。')]),v._v(" "),_("p",[v._v("（4）主线程不断重复上面的第三步")]),v._v(" "),_("p",[_("strong",[v._v("宏任务")]),v._v(": script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering")]),v._v(" "),_("p",[_("strong",[v._v("微任务")]),v._v(": process.nextTick（Nodejs）, Promises, Object.observe, MutationObserver;")]),v._v(" "),_("p",[_("strong",[v._v("事件循环(event-loop)是什么")])]),v._v(" "),_("img",{staticClass:"img-s",attrs:{src:v.$withBase("/broswer/event-loop.png"),alt:"event-loop"}}),v._v(" "),_("p",[v._v('主线程从"任务队列"中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。此机制具体如下:主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去任务队列中取下一个任务执行.')]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v("console.log('script start');\n\nsetTimeout(function () {\n    console.log('setTimeout---0');\n}, 0);\n\nsetTimeout(function () {\n    console.log('setTimeout---200');\n    setTimeout(function () {\n        console.log('inner-setTimeout---0');\n    });\n    Promise.resolve().then(function () {\n        console.log('promise5');\n    });\n}, 200);\n\nPromise.resolve().then(function () {\n    console.log('promise1');\n}).then(function () {\n    console.log('promise2');\n});\nPromise.resolve().then(function () {\n    console.log('promise3');\n});\nconsole.log('script end');\n\nscript start\nscript end\npromise1\npromise3\npromise2\nsetTimeout---0\nsetTimeout---200\npromise5\ninner-setTimeout---0\n")])])]),_("p",[_("strong",[v._v("为什么会需要event-loop")])]),v._v(" "),_("p",[v._v("因为 JavaScript 是单线程的。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。")]),v._v(" "),_("h3",{attrs:{id:"回流和重绘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回流和重绘"}},[v._v("#")]),v._v(" 回流和重绘")]),v._v(" "),_("p",[v._v("浏览器使用流式布局模型 (Flow Based Layout)。")]),v._v(" "),_("p",[v._v("浏览器会把"),_("code",[v._v("HTML")]),v._v("解析成"),_("code",[v._v("DOM")]),v._v("，把"),_("code",[v._v("CSS")]),v._v("解析成"),_("code",[v._v("CSSOM")]),v._v("，"),_("code",[v._v("DOM")]),v._v("和"),_("code",[v._v("CSSOM")]),v._v("合并就产生了"),_("code",[v._v("RenderTree")]),v._v("。")]),v._v(" "),_("p",[v._v("有了"),_("code",[v._v("RenderTree")]),v._v("，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。")]),v._v(" "),_("p",[v._v("由于浏览器使用流式布局，对"),_("code",[v._v("RenderTree")]),v._v("的计算通常只需要遍历一次就可以完成，但"),_("code",[v._v("table")]),v._v("及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用"),_("code",[v._v("table")]),v._v("布局的原因之一。")]),v._v(" "),_("p",[_("strong",[v._v("回流必将引起重绘，重绘不一定会引起回流")])]),v._v(" "),_("p",[_("strong",[v._v("回流")])]),v._v(" "),_("p",[v._v("当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。")]),v._v(" "),_("p",[v._v("会导致回流的操作：")]),v._v(" "),_("ul",[_("li",[v._v("页面首次渲染")]),v._v(" "),_("li",[v._v("浏览器窗口大小发生改变")]),v._v(" "),_("li",[v._v("元素尺寸或位置发生改变")]),v._v(" "),_("li",[v._v("元素内容变化（文字数量或图片大小等等）")]),v._v(" "),_("li",[v._v("元素字体大小变化")]),v._v(" "),_("li",[v._v("添加或者删除"),_("strong",[v._v("可见")]),v._v("的"),_("code",[v._v("DOM")]),v._v("元素")]),v._v(" "),_("li",[v._v("激活"),_("code",[v._v("CSS")]),v._v("伪类（例如："),_("code",[v._v(":hover")]),v._v("）")]),v._v(" "),_("li",[v._v("查询某些属性或调用某些方法")])]),v._v(" "),_("p",[v._v("一些常用且会导致回流的属性和方法：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("clientWidth")]),v._v("、"),_("code",[v._v("clientHeight")]),v._v("、"),_("code",[v._v("clientTop")]),v._v("、"),_("code",[v._v("clientLeft")])]),v._v(" "),_("li",[_("code",[v._v("offsetWidth")]),v._v("、"),_("code",[v._v("offsetHeight")]),v._v("、"),_("code",[v._v("offsetTop")]),v._v("、"),_("code",[v._v("offsetLeft")])]),v._v(" "),_("li",[_("code",[v._v("scrollWidth")]),v._v("、"),_("code",[v._v("scrollHeight")]),v._v("、"),_("code",[v._v("scrollTop")]),v._v("、"),_("code",[v._v("scrollLeft")])]),v._v(" "),_("li",[_("code",[v._v("scrollIntoView()")]),v._v("、"),_("code",[v._v("scrollIntoViewIfNeeded()")])]),v._v(" "),_("li",[_("code",[v._v("getComputedStyle()")])]),v._v(" "),_("li",[_("code",[v._v("getBoundingClientRect()")])]),v._v(" "),_("li",[_("code",[v._v("scrollTo()")])])]),v._v(" "),_("p",[_("strong",[v._v("重绘")])]),v._v(" "),_("p",[v._v("当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。")]),v._v(" "),_("p",[_("strong",[v._v("性能")])]),v._v(" "),_("p",[v._v("浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。")]),v._v(" "),_("p",[v._v("当你访问以下属性或方法时，浏览器会立刻清空队列：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("clientWidth")]),v._v("、"),_("code",[v._v("clientHeight")]),v._v("、"),_("code",[v._v("clientTop")]),v._v("、"),_("code",[v._v("clientLeft")])]),v._v(" "),_("li",[_("code",[v._v("offsetWidth")]),v._v("、"),_("code",[v._v("offsetHeight")]),v._v("、"),_("code",[v._v("offsetTop")]),v._v("、"),_("code",[v._v("offsetLeft")])]),v._v(" "),_("li",[_("code",[v._v("scrollWidth")]),v._v("、"),_("code",[v._v("scrollHeight")]),v._v("、"),_("code",[v._v("scrollTop")]),v._v("、"),_("code",[v._v("scrollLeft")])]),v._v(" "),_("li",[_("code",[v._v("width")]),v._v("、"),_("code",[v._v("height")])]),v._v(" "),_("li",[_("code",[v._v("getComputedStyle()")])]),v._v(" "),_("li",[_("code",[v._v("getBoundingClientRect()")])])]),v._v(" "),_("p",[_("strong",[v._v("如何避免")])]),v._v(" "),_("p",[v._v("触发硬件加速的css属性：")]),v._v(" "),_("ul",[_("li",[v._v("transform")]),v._v(" "),_("li",[v._v("opacity")]),v._v(" "),_("li",[v._v("filters")]),v._v(" "),_("li",[v._v("will-change")])]),v._v(" "),_("p",[_("strong",[v._v("CSS")])]),v._v(" "),_("ul",[_("li",[v._v("避免使用"),_("code",[v._v("table")]),v._v("布局。")]),v._v(" "),_("li",[v._v("尽可能在"),_("code",[v._v("DOM")]),v._v("树的最末端改变"),_("code",[v._v("class")]),v._v("。")]),v._v(" "),_("li",[v._v("避免设置多层内联样式。")]),v._v(" "),_("li",[v._v("将动画效果应用到"),_("code",[v._v("position")]),v._v("属性为"),_("code",[v._v("absolute")]),v._v("或"),_("code",[v._v("fixed")]),v._v("的元素上。")]),v._v(" "),_("li",[v._v("避免使用"),_("code",[v._v("CSS")]),v._v("表达式（例如："),_("code",[v._v("calc()")]),v._v("）。")])]),v._v(" "),_("p",[_("strong",[v._v("JavaScript")])]),v._v(" "),_("ul",[_("li",[v._v("避免频繁操作样式，最好一次性重写"),_("code",[v._v("style")]),v._v("属性，或者将样式列表定义为"),_("code",[v._v("class")]),v._v("并一次性更改"),_("code",[v._v("class")]),v._v("属性。")]),v._v(" "),_("li",[v._v("避免频繁操作"),_("code",[v._v("DOM")]),v._v("，创建一个"),_("code",[v._v("documentFragment")]),v._v("，在它上面应用所有"),_("code",[v._v("DOM操作")]),v._v("，最后再把它添加到文档中。")]),v._v(" "),_("li",[v._v("也可以先为元素设置"),_("code",[v._v("display: none")]),v._v("，操作结束后再把它显示出来。因为在"),_("code",[v._v("display")]),v._v("属性为"),_("code",[v._v("none")]),v._v("的元素上进行的"),_("code",[v._v("DOM")]),v._v("操作不会引发回流和重绘。")]),v._v(" "),_("li",[v._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")]),v._v(" "),_("li",[v._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。")])]),v._v(" "),_("h3",{attrs:{id:"缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[v._v("#")]),v._v(" 缓存")]),v._v(" "),_("p",[v._v("优先级:")]),v._v(" "),_("ol",[_("li",[v._v("Service Worker")]),v._v(" "),_("li",[v._v("Memory Cache")]),v._v(" "),_("li",[v._v("Disk Cache")])]),v._v(" "),_("p",[v._v("浏览器的资源缓存分为 from disk cache 和 from memory cache 两类。当首次访问网页时，资源文件被缓存在内存中，同时也会在本地磁盘中保留一份副本。当用户刷新页面，如果缓存的资源没有过期，那么直接从内存中读取并加载。当用户关闭页面后，当前页面缓存在内存中的资源被清空。当用户再一次访问页面时，如果资源文件的缓存没有过期，那么将从本地磁盘进行加载并再次缓存到内存之中。")]),v._v(" "),_("img",{attrs:{src:v.$withBase("/broswer/cache.png")}}),v._v(" "),_("p",[_("strong",[v._v("强缓存")])]),v._v(" "),_("p",[v._v("强缓存是指客户端在第一次请求后，有效时间内不会再去请求服务器，而是直接使用缓存数据。")]),v._v(" "),_("p",[v._v("HTTP 1.0 版本规定响应头字段 Expires")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v("Expires:Tue, 13 May 2020 09:33:34 GMT\n")])])]),_("p",[v._v("上述 Expires 信息告诉浏览器：在 2020.05.13 号之前,可以直接使用该文本的缓存副本。")]),v._v(" "),_("p",[v._v("Expires 为负数，那么就等同于 no-cache，正数或零同 max-age 的表意是相同的。")]),v._v(" "),_("p",[v._v("使用 Expires 响应头存在一些小的瑕疵，比如：")]),v._v(" "),_("ul",[_("li",[v._v("可能会因为服务器和客户端的 GMT 时间不同，出现偏差")]),v._v(" "),_("li",[v._v("如果修改了本地时间，那么客户端端日期可能不准确")]),v._v(" "),_("li",[v._v("写法太复杂，字符串多个空格，少个字母，都会导致非法属性从而设置失效")])]),v._v(" "),_("p",[v._v("在 HTTP 1.1 版本中，服务端使用 Cache-control 这个响应头")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v("Cache-Control:private, max-age=0, must-revalidate\n// 它表示：该资源只能被浏览器缓存，而不能被代理缓存。max-age 标识为 0，说明该缓存资源立即过期，must-revalidate 告诉浏览器，需要验证文件是否过期，接下来可能会使用协商缓存进行判断。\n")])])]),_("ul",[_("li",[v._v("private：表示私有缓存，不能被共有缓存代理服务器缓存，不能在用户间共享，可被用户的浏览器缓存。")]),v._v(" "),_("li",[v._v("public：表示共有缓存，可被代理服务器缓存，比如 CDN，允许多用户间共享")]),v._v(" "),_("li",[v._v("max-age：值以秒为单位，表示缓存的内容会在该值后过期")]),v._v(" "),_("li",[v._v("no-cache：需要使用协商缓存，协商缓存的内容我们后面介绍。注意这个字段并不表示不使用缓存")]),v._v(" "),_("li",[v._v("no-store：所有内容都不会被缓存")]),v._v(" "),_("li",[v._v("must-revalidate：告诉浏览器，你这必须再次验证检查信息是否过期, 返回的代号就不是 200 而是 304 了")])]),v._v(" "),_("p",[_("strong",[v._v("HTTP 规定，如果 Cache-control 的 max-age 和 Expires 同时出现，那么 max-age 的优先级更高，他会默认覆盖掉 expires。")])]),v._v(" "),_("p",[_("strong",[v._v("协商缓存")])]),v._v(" "),_("p",[v._v("在浏览器端，当对某个资源的请求没有命中强缓存时，浏览器就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 HTTP 状态为 304")]),v._v(" "),_("p",[_("strong",[v._v("Last-Modified，If-Modified-Since")])]),v._v(" "),_("ul",[_("li",[v._v("浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，这个字段表示这个资源在服务器上的最近修改时间")])]),v._v(" "),_("p",[_("code",[v._v("Last-Modified: Tue, 12 Jan 2019 09:08:53 GMT")])]),v._v(" "),_("ul",[_("li",[v._v("浏览器收到响应，并记录 Last-Modified 这个响应头的值为 T")]),v._v(" "),_("li",[v._v("当浏览器再次向服务端请求该资源时，请求头加上 If-Modified-Since 的 header，这个 If-Modified-Since 的值正是上一次请求该资源时，后端返回的 Last-Modified 响应头值 T")]),v._v(" "),_("li",[v._v("服务端再次收到请求，根据请求头 If-Modified-Since 的值 T，判断相关资源是否在 T 时间后有变化；如果没有变化则返回 304 Not Modified，且并不返回资源内容，浏览器使用资源缓存值；如果有变化，则正常返回资源内容，且更新 Last-Modified 响应头内容")])]),v._v(" "),_("p",[_("strong",[v._v("ETag、If-None-Match")])]),v._v(" "),_("ul",[_("li",[v._v("浏览器第一次请求资源，服务端在返回资源的响应头中加入 Etag，Etag 能够弥补 Last-Modified 的问题，因为 Etag 的生成过程类似文件 hash 值，Etag 是一个字符串，不同文件内容对应不同的 Etag 值")])]),v._v(" "),_("p",[_("code",[v._v('ETag:"751F63A30AB5F98F855D1D90D217B356"')])]),v._v(" "),_("ul",[_("li",[v._v("浏览器收到响应，记录 Etag 这个响应头的值为 E")]),v._v(" "),_("li",[v._v("浏览器再次跟服务器请求这个资源时，在请求头上加上 If-None-Match，值为 Etag 这个响应头的值 E")]),v._v(" "),_("li",[v._v("服务端再次收到请求，根据请求头 If-None-Match 的值 E，根据资源生成一个新的 ETag，对比 E 和新的 Etag：如果两值相同，则说明资源没有变化，返回 304 Not Modified，同时携带着新的 ETag 响应头；如果两值不同，就正常返回资源内容，这时也更新 ETag 响应头")]),v._v(" "),_("li",[v._v("浏览器收到 304 的响应后，就会从缓存中加载资源")])]),v._v(" "),_("p",[v._v("Etag 的生成策略，实际上规范并没有强制说明，这就取决于各大厂商或平台的自主实现方式了：Apache 中，ETag 的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行混淆后得到的；MDN 使用 wiki 内容的十六进制数字的哈希值")]),v._v(" "),_("p",[_("strong",[v._v("Etag 优先级比 Last-Modified 高")]),v._v("，如果他们组合出现在请求头当中，我们会优先采用 Etag 策略。同时 Etag 也有自己的问题：相同的资源，在两台服务器产生的 Etag 是不是相同的，所以对于使用服务器集群来处理请求的网站来说， Etag 的匹配概率会大幅降低。所在在这种情况下，使用 Etag 来处理缓存，反而会有更大的开销。")]),v._v(" "),_("p",[_("strong",[v._v("优先级上：Cache-Control > Expires > ETag > Last-Modified")])]),v._v(" "),_("h3",{attrs:{id:"service-worker"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[v._v("#")]),v._v(" Service Worker")]),v._v(" "),_("p",[v._v("不懂")]),v._v(" "),_("h3",{attrs:{id:"提高缓存命中率"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#提高缓存命中率"}},[v._v("#")]),v._v(" 提高缓存命中率")]),v._v(" "),_("p",[v._v("命中：可以直接通过缓存获取到需要的数据。")]),v._v(" "),_("p",[v._v("不命中：无法直接通过缓存获取到想要的数据，需要再次查询数据库或者执行其它的操作。原因可能是由于缓存中根本不存在，或者缓存已经过期。")]),v._v(" "),_("p",[_("strong",[v._v("1.缓存的设计（粒度和策略）")])]),v._v(" "),_("p",[v._v("缓存的粒度越小，命中率会越高.")]),v._v(" "),_("p",[v._v("只有当该对象对应的数据发生变化时，我们才需要更新缓存或者让移除缓存。而当缓存一个集合的时候（例如：所有用户数据），其中任何一个对象对应的数据发生变化时，都需要更新或移除缓存。")]),v._v(" "),_("p",[_("strong",[v._v("2.缓存容量和基础设施")])]),v._v(" "),_("p",[v._v("缓存的容量有限，则容易引起缓存失效和被淘汰.")]),v._v(" "),_("h3",{attrs:{id:"缓存和浏览器操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存和浏览器操作"}},[v._v("#")]),v._v(" 缓存和浏览器操作")]),v._v(" "),_("ul",[_("li",[v._v("当用户 Ctrl + F5 强制刷新网页时，浏览器直接从服务器加载，跳过强缓存和协商缓存")]),v._v(" "),_("li",[v._v("当用户仅仅敲击 F5 刷新网页时，跳过强缓存，但是仍然会进行协商缓存过程")])]),v._v(" "),_("img",{attrs:{src:v.$withBase("/broswer/cache-broswer.png")}}),v._v(" "),_("p",[_("strong",[v._v("如何禁止浏览器缓存静态资源")])]),v._v(" "),_("p",[v._v("使用 Chrome 隐私模式，在代码层面可以设置相关请求头：")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v("Cache-Control: no-cache, no-store, must-revalidate\n")])])]),_("p",[v._v("也可以给请求的资源增加一个版本号")]),v._v(" "),_("p",[v._v("或者meta")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v('＜meta http-equiv="Pragma" content="no-cache"＞\n')])])]),_("h3",{attrs:{id:"domcontentloaded"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#domcontentloaded"}},[v._v("#")]),v._v(" DOMContentLoaded")]),v._v(" "),_("p",[v._v("当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。")]),v._v(" "),_("p",[_("strong",[v._v("CSS 加载会阻塞 Dom 的渲染和后面 js 的执行,js 会阻塞 Dom 解析")])]),v._v(" "),_("p",[v._v("当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。")]),v._v(" "),_("h3",{attrs:{id:"crp关键渲染路径"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#crp关键渲染路径"}},[v._v("#")]),v._v(" CRP关键渲染路径")]),v._v(" "),_("p",[v._v("关键渲染路径是浏览器将 HTML CSS JavaScript 转换为在屏幕上呈现的像素内容所经历的一系列步骤。也就是浏览器渲染流程。")]),v._v(" "),_("ul",[_("li",[v._v("关键资源的数量: 可能阻止网页首次渲染的资源。")]),v._v(" "),_("li",[v._v("关键路径长度: 获取所有关键资源所需的往返次数或总时间。")]),v._v(" "),_("li",[v._v("关键字节: 实现网页首次渲染所需的总字节数,等同于所有关键资源传送文件大小的总和。")])]),v._v(" "),_("h3",{attrs:{id:"渲染层合并"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染层合并"}},[v._v("#")]),v._v(" 渲染层合并")]),v._v(" "),_("img",{attrs:{src:v.$withBase("/broswer/render-layer.png")}}),v._v(" "),_("p",[v._v("RenderLayers 渲染层,这是负责对应 DOM 子树。")]),v._v(" "),_("p",[v._v("GraphicsLayers 图形层,这是负责对应 RenderLayers 子树。")]),v._v(" "),_("p",[v._v("RenderObjects 保持了树结构,一个 RenderObjects 知道如何绘制一个 node 的内容, 他通过向一个绘图上下文（GraphicsContext）发出必要的绘制调用来绘制 nodes。")]),v._v(" "),_("p",[v._v("每个 GraphicsLayer 都有一个 GraphicsContext,GraphicsContext 会负责输出该层的位图,位图是存储在共享内存中,作为纹理上传到 GPU 中,最后由 GPU 将多个位图进行合成,然后 draw 到屏幕上,此时,我们的页面也就展现到了屏幕上。")]),v._v(" "),_("p",[v._v("GraphicsContext 绘图上下文的责任就是向屏幕进行像素绘制(这个过程是先把像素级的数据写入位图中,然后再显示到显示器),在 chrome 里,绘图上下文是包裹了的 Skia（chrome 自己的 2d 图形绘制库）")]),v._v(" "),_("p",[v._v("某些特殊的渲染层会被认为是合成层（Compositing Layers）,合成层拥有单独的 GraphicsLayer,而其他不是合成层的渲染层,则和其第一个拥有 GraphicsLayer 父层公用一个。")]),v._v(" "),_("p",[_("strong",[v._v("合成层的优点")])]),v._v(" "),_("p",[v._v("一旦 renderLayer 提升为了合成层就会有自己的绘图上下文,并且会开启硬件加速,有利于性能提升。")]),v._v(" "),_("ul",[_("li",[v._v("合成层的位图,会交由 GPU 合成,比 CPU 处理要快 (提升到合成层后合成层的位图会交 GPU 处理,但请注意,仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到 GPU,生成合成层的位图处理（绘图上下文的工作）是需要 CPU。)")]),v._v(" "),_("li",[v._v("当需要 repaint 时,只需要 repaint 本身,不会影响到其他的层 (当需要 repaint 的时候可以只 repaint 本身,不影响其他层,但是 paint 之前还有 style, layout,那就意味着即使合成层只是 repaint 了自己,但 style 和 layout 本身就很占用时间。)")]),v._v(" "),_("li",[v._v("对于 transform 和 opacity 效果,不会触发 layout 和 paint (仅仅是 transform 和 opacity 不会引发 layout 和 paint,其他的属性不确定。)")])]),v._v(" "),_("p",[v._v("一般一个元素开启硬件加速后会变成合成层,可以独立于普通文档流中,改动后可以避免整个页面重绘,提升性能。")]),v._v(" "),_("p",[v._v("注意不能滥用 GPU 加速,一定要分析其实际性能表现。因为 GPU 加速创建渲染层是有代价的,每创建一个新的渲染层,就意味着新的内存分配和更复杂的层的管理。并且在移动端 GPU 和 CPU 的带宽有限制,创建的渲染层过多时,合成也会消耗跟多的时间,随之而来的就是耗电更多,内存占用更多。过多的渲染层来带的开销而对页面渲染性能产生的影响,甚至远远超过了它在性能改善上带来的好处。")]),v._v(" "),_("h3",{attrs:{id:"验证-storage-有效性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#验证-storage-有效性"}},[v._v("#")]),v._v(" 验证 storage 有效性")]),v._v(" "),_("p",[v._v("类似Etag的方法")])])}),[],!1,null,null,null);e.default=o.exports}}]);