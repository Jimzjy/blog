(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{358:function(t,e,n){"use strict";n.r(e);var a=n(9),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"webp-图片优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webp-图片优化"}},[t._v("#")]),t._v(" WebP 图片优化")]),t._v(" "),n("p",[t._v("WebP是Google开发的一种新的图片格式，它支持有损压缩、无损压缩和透明度，压缩后的文件大小比JPEG、PNG等都要小。所以可以节省带宽，减少页面载入时间，节省用户的流量。")]),t._v(" "),n("p",[n("strong",[t._v("在浏览器中使用WebP格式")])]),t._v(" "),n("p",[n("strong",[t._v("1.picture标签")])]),t._v(" "),n("p",[t._v("picture是HTML5中的一个新标签，类似video它也可以指定多个格式的资源，由浏览器选择自己支持的格式进行加载。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('<picture class="picture">\n  <source type="image/webp" srcset="image.webp">\n  <img class="image" src="image.jpg">\n</picture>\n')])])]),n("p",[t._v("2."),n("strong",[t._v("使用JS替换图片的URL")])]),t._v(" "),n("p",[t._v("我们有很多的页面往往会用到图片的“懒加载”——通常是把图片的URL放在img元素的一个自定义属性中，然后用JS在适当的时机将URL赋值给src属性。用类似的原理，我们可以根据浏览器是否支持WebP格式，给img元素赋予不同的src值。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("function checkWebp(callback) {\n  var img = new Image();\n  img.onload = function () {\n    var result = (img.width > 0) && (img.height > 0);\n    callback(result);\n  };\n  img.onerror = function () {\n    callback(false);\n  };\n  img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n}\n")])])]),n("p",[t._v("然后用下面的代码来根据是否支持WebP替换相应的src。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("function showImage(useWebp){\n  var imgs = Array.from(document.querySelectorAll('img'));\n\n  imgs.forEach(function(i){\n    var src = i.attributes['data-src'].value;\n\n    if (useWebp){\n      src = src.replace(/\\.jpg$/, '.webp');\n    }\n\n    i.src = src;\n  });\n}\n\ncheckWebp(showImage);\n")])])]),n("p",[t._v("3."),n("strong",[t._v("使用JS解码WebP图片")])]),t._v(" "),n("p",[t._v("webpjs")]),t._v(" "),n("p",[t._v("引入这个JS库，就是将所有的WebP图片用JS解码后转换为base64，然后替换掉原来的URL，这样就可以让原本不支持WebP的浏览器正常显示WebP了")]),t._v(" "),n("h3",{attrs:{id:"按需加载优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#按需加载优化"}},[t._v("#")]),t._v(" 按需加载优化")]),t._v(" "),n("p",[t._v("babel-plugin-dynamic-import-webpack")]),t._v(" "),n("h3",{attrs:{id:"图片懒加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#图片懒加载"}},[t._v("#")]),t._v(" 图片懒加载")]),t._v(" "),n("p",[t._v("把图片的URL放在img元素的一个自定义属性中，然后用JS在适当的时机将URL赋值给src属性")]),t._v(" "),n("p",[n("strong",[t._v("Intersection Observer")])]),t._v(" "),n("h3",{attrs:{id:"雪碧图"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#雪碧图"}},[t._v("#")]),t._v(" 雪碧图")]),t._v(" "),n("p",[t._v("将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示")]),t._v(" "),n("h3",{attrs:{id:"preload-和-prefetch"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#preload-和-prefetch"}},[t._v("#")]),t._v(" preload 和 prefetch")]),t._v(" "),n("p",[t._v("preload 提供了一种声明式的命令，让浏览器提前加载指定资源(加载后并不执行)，在需要执行的时候再执行。提供的好处主要是")]),t._v(" "),n("ul",[n("li",[t._v("将加载和执行分离开，可不阻塞渲染和 document 的 onload 事件")]),t._v(" "),n("li",[t._v("提前加载指定资源，不再出现依赖的font字体隔了一段时间才刷出")])]),t._v(" "),n("p",[n("strong",[t._v("使用 preload")])]),t._v(" "),n("p",[t._v("link 标签")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("\x3c!-- 使用 link 标签静态标记需要预加载的资源 --\x3e\n<link rel=\"preload\" href=\"/path/to/style.css\" as=\"style\">\n\n\x3c!-- 或使用脚本动态创建一个 link 标签后插入到 head 头部 --\x3e\n<script>\nconst link = document.createElement('link');\nlink.rel = 'preload';\nlink.as = 'style';\nlink.href = '/path/to/style.css';\ndocument.head.appendChild(link);\n<\/script>\n")])])]),n("p",[t._v("http头")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("Link: <https://example.com/other/styles.css>; rel=preload; as=style\n")])])]),n("ul",[n("li",[t._v("preload 是告诉浏览器页面"),n("strong",[t._v("必定")]),t._v("需要的资源，浏览器"),n("strong",[t._v("一定会")]),t._v("加载这些资源；")]),t._v(" "),n("li",[t._v("prefetch 是告诉浏览器页面"),n("strong",[t._v("可能")]),t._v("需要的资源，浏览器"),n("strong",[t._v("不一定会")]),t._v("加载这些资源。")])]),t._v(" "),n("p",[t._v("preload 是确认会加载指定资源，如在我们的场景中，x-report.js 初始化后一定会加载 PcCommon.js 和 TabsPc.js, 则可以预先 preload 这些资源；")]),t._v(" "),n("p",[t._v("prefetch 是预测会加载指定资源，如在我们的场景中，我们在页面加载后会初始化首屏组件，当用户滚动页面时，会拉取第二屏的组件，若能预测用户行为，则可以 prefetch 下一屏的组件。")]),t._v(" "),n("h3",{attrs:{id:"tree-shaking"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking"}},[t._v("#")]),t._v(" tree shaking")]),t._v(" "),n("ol",[n("li",[t._v("ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。")]),t._v(" "),n("li",[t._v("分析程序流，判断哪些变量未被使用、引用，进而删除此代码。")])]),t._v(" "),n("h3",{attrs:{id:"动画性能方向"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动画性能方向"}},[t._v("#")]),t._v(" 动画性能方向")]),t._v(" "),n("ul",[n("li",[t._v("一般 CSS3 动画会比基于 JavaScript 实现的动画效率要高，因此优先使用 CSS3 实现效果（这一点并不绝对）")]),t._v(" "),n("li",[t._v("在使用 CSS3 实现动画时，考虑开启 GPU 加速（这一点也并不总是正向效果）")]),t._v(" "),n("li",[t._v("优先使用消耗最低的 transform 和 opacity 两个属性 (避免 reflow repaint)")]),t._v(" "),n("li",[t._v("使用 will-change 属性")]),t._v(" "),n("li",[t._v("独立合成层，减少绘制区域")]),t._v(" "),n("li",[t._v("对于只能使用 JavaScript 实现动画效果的情况，考虑 requestAnimationFrame、requestIdleCallback API")]),t._v(" "),n("li",[t._v("批量进行样式变换，减少布局抖动")])]),t._v(" "),n("p",[n("strong",[t._v("如何开启 GPU 加速")])]),t._v(" "),n("p",[t._v("触发硬件加速的css属性：")]),t._v(" "),n("ul",[n("li",[t._v("transform")]),t._v(" "),n("li",[t._v("opacity")]),t._v(" "),n("li",[t._v("filters")]),t._v(" "),n("li",[t._v("Will-change")])]),t._v(" "),n("p",[t._v("目前下面这些因素都会引起Chrome创建合成层：")]),t._v(" "),n("ol",[n("li",[t._v("3D 或透视变换(perspective，transform) CSS 属性")]),t._v(" "),n("li",[t._v("使用加速视频解码的video元素")]),t._v(" "),n("li",[t._v("拥有 3D (WebGL) 上下文或加速的 2D 上下文的 canvas 元素")]),t._v(" "),n("li",[t._v("混合插件(如 Flash)")]),t._v(" "),n("li",[t._v("对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素")]),t._v(" "),n("li",[t._v("拥有加速 CSS 过滤器的元素")]),t._v(" "),n("li",[t._v("元素A有一个 z-index 比自己小的元素B，且元素B是一个合成层（换句话说就是该元素在复合层上面渲染），则元素A会提升为合成层")])]),t._v(" "),n("h3",{attrs:{id:"事件委托"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件委托"}},[t._v("#")]),t._v(" 事件委托")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("window.onload = () => {\n   const ul = document.getElementsByTagName('ul')[0]\n   const liList = document.getElementsByTagName('li')\n\n   ul.onclick = e => {\n       const normalizeE = e || window.event\n       const target = normalizeE.target || normalizeE.srcElement\n\n       if (target.nodeName.toLowerCase() == \"li\") {\n           alert(target.innerHTML)\n       }\n   }\n}\n")])])]),n("h3",{attrs:{id:"节流和防抖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#节流和防抖"}},[t._v("#")]),t._v(" 节流和防抖")]),t._v(" "),n("ul",[n("li",[t._v("防抖：抖动现象本质就是指短时间内高频次触发。因此，我们可以把短时间内的多个连续调用合并成一次，也就是只触发一次回调函数。")]),t._v(" "),n("li",[t._v("节流：顾名思义，就是将短时间的函数调用以一个固定的频率间隔执行，这就如同水龙头开关限制出水口流量。")])]),t._v(" "),n("p",[n("strong",[t._v("防抖")])]),t._v(" "),n("p",[t._v("采取最后一次")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("const debounce = (func, wait) => {\n   let timeout\n   return function () {\n       const context = this\n       const args = arguments\n\n       timeout && clearTimeout(timeout)\n       timeout = setTimeout(function() {\n           timeout = null\n           func.apply(context, args)\n       }, wait)\n   }\n}\n\nconst debounce = (func, wait, immediate) => {\n   let timeout\n   return function () {\n       const context = this\n       const args = arguments\n\n       const callNow = immediate && !timeout\n\n       timeout && clearTimeout(timeout)\n\n       timeout = setTimeout(function() {\n           timeout = null\n           if (!immediate) func.apply(context, args)\n       }, wait)\n\n       if (callNow) func.apply(context, args)\n   }\n}\n")])])]),n("p",[n("strong",[t._v("节流")])]),t._v(" "),n("p",[t._v("采取第一次")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("const throttle = (func, wait) => {\n   let startTime = 0\n   return function() {\n       let handleTime = +new Date()\n       let context = this\n       const args = arguments\n\n       if (handleTime - startTime >= wait) {\n           func.apply(context, args)\n           startTime = handleTime\n       }\n   }\n}\n\nconst throttle = (func, wait) => {\n   let timeout\n\n   return function () {\n       const context = this\n       const args = arguments\n       if (!timeout) {\n           timeout = setTimeout(function() {\n               func.apply(context, args)\n                  timeout = null\n         }, wait)\n       }\n   }\n}")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);