<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器相关 | Jimzjy Blog</title>
    <meta name="description" content="
执行过程

加载： 根据请求的url进行域名解析，然后向服务器发送请求，接收响应文件（如HTML、CSS、JS、图片等）.

解析： 对加载到的资源（HTML、CSS、JS等）进行语法解析，构建响应的内部数据结构（如HTML的DOM树，JS对象的属性表，css样式规则等）.

渲染： 构建渲染树，对各个元素进行位置计算、样式计算等，然后根据渲染书完成页面的布局及 ...">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/blog/assets/css/0.styles.21a25359.css" as="style"><link rel="preload" href="/blog/assets/js/app.ca1f4ec1.js" as="script"><link rel="preload" href="/blog/assets/js/6.efbb1a0e.js" as="script"><link rel="preload" href="/blog/assets/js/4.9413832c.js" as="script"><link rel="preload" href="/blog/assets/js/14.8f29e91d.js" as="script"><link rel="prefetch" href="/blog/assets/js/1.e55fcec3.js"><link rel="prefetch" href="/blog/assets/js/10.51af10c9.js"><link rel="prefetch" href="/blog/assets/js/11.51ffef52.js"><link rel="prefetch" href="/blog/assets/js/12.0ff238b0.js"><link rel="prefetch" href="/blog/assets/js/13.d330772c.js"><link rel="prefetch" href="/blog/assets/js/15.b62da3a4.js"><link rel="prefetch" href="/blog/assets/js/16.10986ce8.js"><link rel="prefetch" href="/blog/assets/js/17.8d7b4284.js"><link rel="prefetch" href="/blog/assets/js/18.ba0bb098.js"><link rel="prefetch" href="/blog/assets/js/19.a4142895.js"><link rel="prefetch" href="/blog/assets/js/20.19b250e8.js"><link rel="prefetch" href="/blog/assets/js/21.b7728ef8.js"><link rel="prefetch" href="/blog/assets/js/22.908eeb8b.js"><link rel="prefetch" href="/blog/assets/js/23.406a7a8e.js"><link rel="prefetch" href="/blog/assets/js/24.b7095e8d.js"><link rel="prefetch" href="/blog/assets/js/25.cace9b50.js"><link rel="prefetch" href="/blog/assets/js/26.ca87b790.js"><link rel="prefetch" href="/blog/assets/js/5.860e13d9.js"><link rel="prefetch" href="/blog/assets/js/7.b5dcbd12.js"><link rel="prefetch" href="/blog/assets/js/8.5c3b217f.js"><link rel="prefetch" href="/blog/assets/js/9.e865db1b.js"><link rel="prefetch" href="/blog/assets/js/vuejs-paginate.8d2cad8c.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.21a25359.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/blog/" class="nav-link home-link">Jimzjy Blog </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/blog/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/blog/tag/memo/" class="nav-link">Memo</a></li><li class="nav-item"><a href="https://github.com/Jimzjy/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">GitHub</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/blog/" class="nav-link mobile-home-link">Jimzjy Blog </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/blog/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/blog/tag/memo/" class="nav-link">Memo</a></li><li class="mobile-nav-item"><a href="https://github.com/Jimzjy/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">GitHub</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        浏览器相关
      </h1> <div class="post-meta"><!----> <!----> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-d832e844><a href="/blog/tag/memo" data-v-d832e844> memo </a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h1 id="浏览器相关"><a href="#浏览器相关" class="header-anchor">#</a> 浏览器相关</h1> <h3 id="执行过程"><a href="#执行过程" class="header-anchor">#</a> 执行过程</h3> <p><strong>加载：</strong> 根据请求的url进行域名解析，然后向服务器发送请求，接收响应文件（如HTML、CSS、JS、图片等）.</p> <p><strong>解析：</strong> 对加载到的资源（HTML、CSS、JS等）进行语法解析，构建响应的内部数据结构（如HTML的DOM树，JS对象的属性表，css样式规则等）.</p> <p><strong>渲染：</strong> 构建渲染树，对各个元素进行位置计算、样式计算等，然后根据渲染书完成页面的布局及绘制的过程（产生页面的元素）.</p> <ol><li>解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件</li> <li>CSS 文件下载完成,解析 CSS 文件成树形的数据结构,然后结合 DOM 树合并成 RenderObject 树</li> <li>布局 RenderObject 树 （Layout/reflow）,负责 RenderObject 树中的元素的尺寸,位置等计算</li> <li>绘制 RenderObject 树 （paint）,绘制页面的像素信息</li> <li>浏览器主进程将默认的图层和复合图层交给 GPU 进程,GPU 进程再将各个图层合成（composite）,最后显示出页面</li></ol> <p><img src="/broswer/run.png" alt="执行过程"></p> <h3 id="浏览器线程"><a href="#浏览器线程" class="header-anchor">#</a> 浏览器线程</h3> <p>浏览器是拥有多个线程的比如：gui渲染线程、JS引擎线程、事件触发线程、异步http请求线程</p> <h3 id="event-loop"><a href="#event-loop" class="header-anchor">#</a> Event Loop</h3> <p><strong>JavaScript的运行机制</strong></p> <p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p> <p>（2）主线程之外，还存在&quot;任务队列&quot;(task queue)。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</p> <p>（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p> <p>（4）主线程不断重复上面的第三步</p> <p><strong>宏任务</strong>: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering</p> <p><strong>微任务</strong>: process.nextTick（Nodejs）, Promises, Object.observe, MutationObserver;</p> <p><strong>事件循环(event-loop)是什么</strong></p> <img src="/blog/broswer/event-loop.png" alt="event-loop" class="img-s"> <p>主线程从&quot;任务队列&quot;中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。此机制具体如下:主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去任务队列中取下一个任务执行.</p> <div class="language- extra-class"><pre><code>console.log('script start');

setTimeout(function () {
    console.log('setTimeout---0');
}, 0);

setTimeout(function () {
    console.log('setTimeout---200');
    setTimeout(function () {
        console.log('inner-setTimeout---0');
    });
    Promise.resolve().then(function () {
        console.log('promise5');
    });
}, 200);

Promise.resolve().then(function () {
    console.log('promise1');
}).then(function () {
    console.log('promise2');
});
Promise.resolve().then(function () {
    console.log('promise3');
});
console.log('script end');

script start
script end
promise1
promise3
promise2
setTimeout---0
setTimeout---200
promise5
inner-setTimeout---0
</code></pre></div><p><strong>为什么会需要event-loop</strong></p> <p>因为 JavaScript 是单线程的。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。</p> <h3 id="回流和重绘"><a href="#回流和重绘" class="header-anchor">#</a> 回流和重绘</h3> <p>浏览器使用流式布局模型 (Flow Based Layout)。</p> <p>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了<code>RenderTree</code>。</p> <p>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</p> <p>由于浏览器使用流式布局，对<code>RenderTree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一。</p> <p><strong>回流必将引起重绘，重绘不一定会引起回流</strong></p> <p><strong>回流</strong></p> <p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p> <p>会导致回流的操作：</p> <ul><li>页面首次渲染</li> <li>浏览器窗口大小发生改变</li> <li>元素尺寸或位置发生改变</li> <li>元素内容变化（文字数量或图片大小等等）</li> <li>元素字体大小变化</li> <li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li> <li>激活<code>CSS</code>伪类（例如：<code>:hover</code>）</li> <li>查询某些属性或调用某些方法</li></ul> <p>一些常用且会导致回流的属性和方法：</p> <ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li> <li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li> <li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li> <li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li> <li><code>getComputedStyle()</code></li> <li><code>getBoundingClientRect()</code></li> <li><code>scrollTo()</code></li></ul> <p><strong>重绘</strong></p> <p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p> <p><strong>性能</strong></p> <p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p> <p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p> <ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li> <li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li> <li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li> <li><code>width</code>、<code>height</code></li> <li><code>getComputedStyle()</code></li> <li><code>getBoundingClientRect()</code></li></ul> <p><strong>如何避免</strong></p> <p>触发硬件加速的css属性：</p> <ul><li>transform</li> <li>opacity</li> <li>filters</li> <li>will-change</li></ul> <p><strong>CSS</strong></p> <ul><li>避免使用<code>table</code>布局。</li> <li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li> <li>避免设置多层内联样式。</li> <li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li> <li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li></ul> <p><strong>JavaScript</strong></p> <ul><li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li> <li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li> <li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li> <li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li> <li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul> <h3 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h3> <p>优先级:</p> <ol><li>Service Worker</li> <li>Memory Cache</li> <li>Disk Cache</li></ol> <p>浏览器的资源缓存分为 from disk cache 和 from memory cache 两类。当首次访问网页时，资源文件被缓存在内存中，同时也会在本地磁盘中保留一份副本。当用户刷新页面，如果缓存的资源没有过期，那么直接从内存中读取并加载。当用户关闭页面后，当前页面缓存在内存中的资源被清空。当用户再一次访问页面时，如果资源文件的缓存没有过期，那么将从本地磁盘进行加载并再次缓存到内存之中。</p> <p><img src="/broswer/cache.png" alt="缓存策略"></p> <p><strong>强缓存</strong></p> <p>强缓存是指客户端在第一次请求后，有效时间内不会再去请求服务器，而是直接使用缓存数据。</p> <p>HTTP 1.0 版本规定响应头字段 Expires</p> <div class="language- extra-class"><pre><code>Expires:Tue, 13 May 2020 09:33:34 GMT
</code></pre></div><p>上述 Expires 信息告诉浏览器：在 2020.05.13 号之前,可以直接使用该文本的缓存副本。</p> <p>Expires 为负数，那么就等同于 no-cache，正数或零同 max-age 的表意是相同的。</p> <p>使用 Expires 响应头存在一些小的瑕疵，比如：</p> <ul><li>可能会因为服务器和客户端的 GMT 时间不同，出现偏差</li> <li>如果修改了本地时间，那么客户端端日期可能不准确</li> <li>写法太复杂，字符串多个空格，少个字母，都会导致非法属性从而设置失效</li></ul> <p>在 HTTP 1.1 版本中，服务端使用 Cache-control 这个响应头</p> <div class="language- extra-class"><pre><code>Cache-Control:private, max-age=0, must-revalidate
// 它表示：该资源只能被浏览器缓存，而不能被代理缓存。max-age 标识为 0，说明该缓存资源立即过期，must-revalidate 告诉浏览器，需要验证文件是否过期，接下来可能会使用协商缓存进行判断。
</code></pre></div><ul><li>private：表示私有缓存，不能被共有缓存代理服务器缓存，不能在用户间共享，可被用户的浏览器缓存。</li> <li>public：表示共有缓存，可被代理服务器缓存，比如 CDN，允许多用户间共享</li> <li>max-age：值以秒为单位，表示缓存的内容会在该值后过期</li> <li>no-cache：需要使用协商缓存，协商缓存的内容我们后面介绍。注意这个字段并不表示不使用缓存</li> <li>no-store：所有内容都不会被缓存</li> <li>must-revalidate：告诉浏览器，你这必须再次验证检查信息是否过期, 返回的代号就不是 200 而是 304 了</li></ul> <p><strong>HTTP 规定，如果 Cache-control 的 max-age 和 Expires 同时出现，那么 max-age 的优先级更高，他会默认覆盖掉 expires。</strong></p> <p><strong>协商缓存</strong></p> <p>在浏览器端，当对某个资源的请求没有命中强缓存时，浏览器就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 HTTP 状态为 304</p> <p><strong>Last-Modified，If-Modified-Since</strong></p> <ul><li>浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，这个字段表示这个资源在服务器上的最近修改时间</li></ul> <p><code>Last-Modified: Tue, 12 Jan 2019 09:08:53 GMT</code></p> <ul><li>浏览器收到响应，并记录 Last-Modified 这个响应头的值为 T</li> <li>当浏览器再次向服务端请求该资源时，请求头加上 If-Modified-Since 的 header，这个 If-Modified-Since 的值正是上一次请求该资源时，后端返回的 Last-Modified 响应头值 T</li> <li>服务端再次收到请求，根据请求头 If-Modified-Since 的值 T，判断相关资源是否在 T 时间后有变化；如果没有变化则返回 304 Not Modified，且并不返回资源内容，浏览器使用资源缓存值；如果有变化，则正常返回资源内容，且更新 Last-Modified 响应头内容</li></ul> <p><strong>ETag、If-None-Match</strong></p> <ul><li>浏览器第一次请求资源，服务端在返回资源的响应头中加入 Etag，Etag 能够弥补 Last-Modified 的问题，因为 Etag 的生成过程类似文件 hash 值，Etag 是一个字符串，不同文件内容对应不同的 Etag 值</li></ul> <p><code>ETag:&quot;751F63A30AB5F98F855D1D90D217B356&quot;</code></p> <ul><li>浏览器收到响应，记录 Etag 这个响应头的值为 E</li> <li>浏览器再次跟服务器请求这个资源时，在请求头上加上 If-None-Match，值为 Etag 这个响应头的值 E</li> <li>服务端再次收到请求，根据请求头 If-None-Match 的值 E，根据资源生成一个新的 ETag，对比 E 和新的 Etag：如果两值相同，则说明资源没有变化，返回 304 Not Modified，同时携带着新的 ETag 响应头；如果两值不同，就正常返回资源内容，这时也更新 ETag 响应头</li> <li>浏览器收到 304 的响应后，就会从缓存中加载资源</li></ul> <p>Etag 的生成策略，实际上规范并没有强制说明，这就取决于各大厂商或平台的自主实现方式了：Apache 中，ETag 的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行混淆后得到的；MDN 使用 wiki 内容的十六进制数字的哈希值</p> <p><strong>Etag 优先级比 Last-Modified 高</strong>，如果他们组合出现在请求头当中，我们会优先采用 Etag 策略。同时 Etag 也有自己的问题：相同的资源，在两台服务器产生的 Etag 是不是相同的，所以对于使用服务器集群来处理请求的网站来说， Etag 的匹配概率会大幅降低。所在在这种情况下，使用 Etag 来处理缓存，反而会有更大的开销。</p> <p><strong>优先级上：Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</strong></p> <h3 id="service-worker"><a href="#service-worker" class="header-anchor">#</a> Service Worker</h3> <p>不懂</p> <h3 id="提高缓存命中率"><a href="#提高缓存命中率" class="header-anchor">#</a> 提高缓存命中率</h3> <p>命中：可以直接通过缓存获取到需要的数据。</p> <p>不命中：无法直接通过缓存获取到想要的数据，需要再次查询数据库或者执行其它的操作。原因可能是由于缓存中根本不存在，或者缓存已经过期。</p> <p><strong>1.缓存的设计（粒度和策略）</strong></p> <p>缓存的粒度越小，命中率会越高.</p> <p>只有当该对象对应的数据发生变化时，我们才需要更新缓存或者让移除缓存。而当缓存一个集合的时候（例如：所有用户数据），其中任何一个对象对应的数据发生变化时，都需要更新或移除缓存。</p> <p><strong>2.缓存容量和基础设施</strong></p> <p>缓存的容量有限，则容易引起缓存失效和被淘汰.</p> <h3 id="缓存和浏览器操作"><a href="#缓存和浏览器操作" class="header-anchor">#</a> 缓存和浏览器操作</h3> <ul><li>当用户 Ctrl + F5 强制刷新网页时，浏览器直接从服务器加载，跳过强缓存和协商缓存</li> <li>当用户仅仅敲击 F5 刷新网页时，跳过强缓存，但是仍然会进行协商缓存过程</li></ul> <p><img src="/broswer/cache-broswer.png" alt="缓存和浏览器操作"></p> <p><strong>如何禁止浏览器缓存静态资源</strong></p> <p>使用 Chrome 隐私模式，在代码层面可以设置相关请求头：</p> <div class="language- extra-class"><pre><code>Cache-Control: no-cache, no-store, must-revalidate
</code></pre></div><p>也可以给请求的资源增加一个版本号</p> <p>或者meta</p> <div class="language- extra-class"><pre><code>＜meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;＞
</code></pre></div><h3 id="domcontentloaded"><a href="#domcontentloaded" class="header-anchor">#</a> DOMContentLoaded</h3> <p>当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。</p> <p><strong>CSS 加载会阻塞 Dom 的渲染和后面 js 的执行,js 会阻塞 Dom 解析</strong></p> <p>当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。</p> <h3 id="crp关键渲染路径"><a href="#crp关键渲染路径" class="header-anchor">#</a> CRP关键渲染路径</h3> <p>关键渲染路径是浏览器将 HTML CSS JavaScript 转换为在屏幕上呈现的像素内容所经历的一系列步骤。也就是浏览器渲染流程。</p> <ul><li>关键资源的数量: 可能阻止网页首次渲染的资源。</li> <li>关键路径长度: 获取所有关键资源所需的往返次数或总时间。</li> <li>关键字节: 实现网页首次渲染所需的总字节数,等同于所有关键资源传送文件大小的总和。</li></ul> <h3 id="渲染层合并"><a href="#渲染层合并" class="header-anchor">#</a> 渲染层合并</h3> <p><img src="/broswer/render-layer.png" alt="渲染层合并"></p> <p>RenderLayers 渲染层,这是负责对应 DOM 子树。</p> <p>GraphicsLayers 图形层,这是负责对应 RenderLayers 子树。</p> <p>RenderObjects 保持了树结构,一个 RenderObjects 知道如何绘制一个 node 的内容, 他通过向一个绘图上下文（GraphicsContext）发出必要的绘制调用来绘制 nodes。</p> <p>每个 GraphicsLayer 都有一个 GraphicsContext,GraphicsContext 会负责输出该层的位图,位图是存储在共享内存中,作为纹理上传到 GPU 中,最后由 GPU 将多个位图进行合成,然后 draw 到屏幕上,此时,我们的页面也就展现到了屏幕上。</p> <p>GraphicsContext 绘图上下文的责任就是向屏幕进行像素绘制(这个过程是先把像素级的数据写入位图中,然后再显示到显示器),在 chrome 里,绘图上下文是包裹了的 Skia（chrome 自己的 2d 图形绘制库）</p> <p>某些特殊的渲染层会被认为是合成层（Compositing Layers）,合成层拥有单独的 GraphicsLayer,而其他不是合成层的渲染层,则和其第一个拥有 GraphicsLayer 父层公用一个。</p> <p><strong>合成层的优点</strong></p> <p>一旦 renderLayer 提升为了合成层就会有自己的绘图上下文,并且会开启硬件加速,有利于性能提升。</p> <ul><li>合成层的位图,会交由 GPU 合成,比 CPU 处理要快 (提升到合成层后合成层的位图会交 GPU 处理,但请注意,仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到 GPU,生成合成层的位图处理（绘图上下文的工作）是需要 CPU。)</li> <li>当需要 repaint 时,只需要 repaint 本身,不会影响到其他的层 (当需要 repaint 的时候可以只 repaint 本身,不影响其他层,但是 paint 之前还有 style, layout,那就意味着即使合成层只是 repaint 了自己,但 style 和 layout 本身就很占用时间。)</li> <li>对于 transform 和 opacity 效果,不会触发 layout 和 paint (仅仅是 transform 和 opacity 不会引发 layout 和 paint,其他的属性不确定。)</li></ul> <p>一般一个元素开启硬件加速后会变成合成层,可以独立于普通文档流中,改动后可以避免整个页面重绘,提升性能。</p> <p>注意不能滥用 GPU 加速,一定要分析其实际性能表现。因为 GPU 加速创建渲染层是有代价的,每创建一个新的渲染层,就意味着新的内存分配和更复杂的层的管理。并且在移动端 GPU 和 CPU 的带宽有限制,创建的渲染层过多时,合成也会消耗跟多的时间,随之而来的就是耗电更多,内存占用更多。过多的渲染层来带的开销而对页面渲染性能产生的影响,甚至远远超过了它在性能改善上带来的好处。</p> <h3 id="验证-storage-有效性"><a href="#验证-storage-有效性" class="header-anchor">#</a> 验证 storage 有效性</h3> <p>类似Etag的方法</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h3 active"><a href="#执行过程" title="执行过程">执行过程</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#浏览器线程" title="浏览器线程">浏览器线程</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#event-loop" title="Event Loop">Event Loop</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#回流和重绘" title="回流和重绘">回流和重绘</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#缓存" title="缓存">缓存</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#service-worker" title="Service Worker">Service Worker</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#提高缓存命中率" title="提高缓存命中率">提高缓存命中率</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#缓存和浏览器操作" title="缓存和浏览器操作">缓存和浏览器操作</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#domcontentloaded" title="DOMContentLoaded">DOMContentLoaded</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#crp关键渲染路径" title="CRP关键渲染路径">CRP关键渲染路径</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#渲染层合并" title="渲染层合并">渲染层合并</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#验证-storage-有效性" title="验证 storage 有效性">验证 storage 有效性</a></div></div></div></div> <footer class="footer" data-v-582f9766><div class="footer-left-wrap" data-v-582f9766><ul class="contact" data-v-582f9766></ul></div> <div class="footer-right-wrap" data-v-582f9766><ul class="copyright" data-v-582f9766></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.ca1f4ec1.js" defer></script><script src="/blog/assets/js/6.efbb1a0e.js" defer></script><script src="/blog/assets/js/4.9413832c.js" defer></script><script src="/blog/assets/js/14.8f29e91d.js" defer></script>
  </body>
</html>
